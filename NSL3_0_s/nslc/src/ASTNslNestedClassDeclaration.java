/* Generated By:JJTree: Do not edit this line. ASTNslNestedClassDeclaration.java */

/* SCCS  %W--- %G% -- %U% */

// Copyright: Copyright (c) 1997-2002 University of Southern California Brain Project.
// Copyright: This software may be freely copied provided the toplevel
// Copyright: COPYRIGHT file is included with each such copy.
// Copyright: Email nsl@java.usc.edu.

// Author: Salvador Marmol

import java.util.Enumeration;
import java.util.Vector;

@SuppressWarnings("Duplicates")
public class ASTNslNestedClassDeclaration extends SimpleNode {

    private boolean inherits = false;
    private static String endLine = System.getProperty("line.separator");
    private NslScope localScope = null;

    public ASTNslNestedClassDeclaration(int id) {
        super(id);
    }

    public ASTNslNestedClassDeclaration(NslParser p, int id) {
        super(p, id);
    }


    /**
     * Accept the visitor.
     **/
    public Object jjtAccept(NslParserVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }

    public void setExtends(boolean value) {
        inherits = value;
    }

    public boolean getExtends() {
        return inherits;
    }

    public NslScope getLocalScope() {
        return localScope;
    }

    public String getSuperClass() {
        if (inherits) {
            ASTName nameNode = (ASTName) jjtGetChild(1);
            return nameNode.getName();
        } else {
            return "N" + getKind().substring(1);
        }
    }

    public String getClassName() {
        Token t = first.next;
        return t.image;
    }

    public String getKind() {
        Token t = first;
        return t.image;
    }

    public String toJava(NslScope scope) {

        String code = "public class ";
        code += getClassName();
        code += " extends " + getSuperClass();

        String nslCode = genNslCode(scope);

        first.image = code;

        int bodyIndex = (inherits ? 3 : 1);
        SimpleNode body = (SimpleNode) jjtGetChild(bodyIndex);

        first.next = body.getFirstToken();

        Token newCode = new Token();

        newCode.kind = last.kind;
        newCode.beginLine = last.beginLine;
        newCode.beginColumn = last.beginColumn;
        newCode.endLine = last.endLine;
        newCode.endColumn = last.endColumn;
        newCode.image = last.image;
        newCode.next = last.next;
        newCode.specialToken = last.specialToken;


        last.image = nslCode;
        last.next = newCode;

        //clean(first, end);

        return code;
    }

    String genNslCode(NslScope scope) {
        StringBuilder strbuf = new StringBuilder();
        String prefix = getIndentation(first);
        strbuf.append(endLine);
        strbuf.append(prefix).append("\t/******************************************************/").append(endLine);
        strbuf.append(prefix).append("\t/*                                                    */").append(endLine);
        strbuf.append(prefix).append("\t/* Generated by NslCompiler. Do not edit these lines! */").append(endLine);
        strbuf.append(prefix).append("\t/*                                                    */").append(endLine);
        strbuf.append(prefix).append("\t/******************************************************/").append(endLine);
        strbuf.append(endLine);
        strbuf.append(genConstructor(localScope));
        strbuf.append(prefix).append(endLine);
        strbuf.append(prefix).append("\t/******************************************************/").append(endLine);
        strbuf.append(prefix).append("\t/*                                                    */").append(endLine);
        strbuf.append(prefix).append("\t/* End of automatic declaration statements.           */").append(endLine);
        strbuf.append(prefix).append("\t/*                                                    */").append(endLine);
        strbuf.append(prefix).append("\t/******************************************************/").append(endLine);
        strbuf.append(endLine);

        return strbuf.toString();
    }

    String genTempInstStmt(NslScope scope) {

        StringBuilder strbuf = new StringBuilder();

        Vector tempVarList = scope.getTempVarList();
        Enumeration enumer = tempVarList.elements();
        NslVariable fieldTmp;
        String instanceType;
        String instanceName;
        String instanceArguments;
        String staticType = "";
        boolean isNsl;

        while (enumer.hasMoreElements()) {
            fieldTmp = (NslVariable) enumer.nextElement();
            instanceType = fieldTmp.getType();
            instanceName = fieldTmp.getName();
            instanceArguments = "";
            if (instanceType.contains("static ")) {
                instanceType = instanceType.substring(7);
                staticType = "static ";
            }
            isNsl = scope.isNslType(instanceType);
            if (isNsl) {
                instanceType = scope.getNslTypeWithoutPort(instanceType);
                switch (scope.getNslTypeDim(instanceType)) {
                    case 1:
                        instanceArguments = "1";
                        break;
                    case 2:
                        instanceArguments = "1, 1";
                        break;
                    case 3:
                        instanceArguments = "1, 1, 1";
                        break;
                    case 4:
                        instanceArguments = "1, 1, 1, 1";
                        break;
                }
                strbuf.append("\t\t").append(staticType).append(instanceType).append(" ").append(instanceName).append(" = new ").append(instanceType).append("(").append(instanceArguments).append(");").append(endLine);
            } else {
                int dim = scope.getDim(instanceType);
                switch (dim) {
                    case 1:
                        instanceArguments = "[1]";
                        break;
                    case 2:
                        instanceArguments = "[1][1]";
                        break;
                    case 3:
                        instanceArguments = "[1][1][1]";
                        break;
                    case 4:
                        instanceArguments = "[1][1][1][1]";
                        break;
                }
                if (dim > 0) {
                    String newInstanceType = instanceType.substring(0, instanceType.indexOf("["));
                    strbuf.append("\t\t").append(staticType).append(instanceType).append(" ").append(instanceName).append(" = new ").append(newInstanceType).append(instanceArguments).append(";").append(endLine);
                }
            }
        }
        return strbuf.toString();
    }

    String genTempDeclaration(NslScope scope) {

        StringBuilder strbuf = new StringBuilder();

        Vector tempVarList = scope.getTempVarList();
        Enumeration enumer = tempVarList.elements();
        NslVariable fieldTmp;
        String instanceType;
        String instanceName;
        while (enumer.hasMoreElements()) {
            fieldTmp = (NslVariable) enumer.nextElement();
            instanceType = fieldTmp.getType();
            instanceName = fieldTmp.getName();
            instanceType = scope.getNslTypeWithoutPort(instanceType);
            strbuf.append("\t").append(instanceType).append(" ").append(instanceName).append(";").append(endLine);
        }
        return strbuf.toString();
    }

    String genConstructor(NslScope scope) {

        StringBuilder strbuf = new StringBuilder();

        strbuf.append("\t/* Constructor and related methods */").append(endLine);
        strbuf.append("\t/* makeinst() declared variables */").append(endLine);

        String kind = getKind();
        String name = getClassName();
        String newName = name.substring(0, 1).toLowerCase() + name.substring(1);
        String superClass = getSuperClass();

        ASTFormalParameters formals = scope.getClassFormals();
        String[] formalTypes = formals.getTypes();
        String[] formalNames = formals.getNames();
        int numFormals = formalTypes.length;

        ASTArguments argumentsNode = scope.getClassArguments();

        String[] arguments = null;
        int numArguments;
        if (argumentsNode != null) {
            arguments = argumentsNode.getArguments();
            numArguments = arguments.length;
        } else {
            numArguments = 0;
        }

        //
        // Formal Declaration
        //

        strbuf.append(endLine);
        strbuf.append("\t/* Formal parameters */").append(endLine);

        //  Add Formals
        for (int i = 0; i < numFormals; i++) {
            strbuf.append("\t").append(formalTypes[i]).append(" ").append(formalNames[i]).append(";").append(endLine);
        }


        //
        // Temporary Variables Declaration
        //

        strbuf.append(endLine);
        strbuf.append("\t/* Temporary variables */").append(endLine);

        //  Add Temporaries
        strbuf.append(genTempDeclaration(scope));

        // Constructor

        strbuf.append(endLine);
        strbuf.append("\tpublic ").append(name).append("(String nslName, NslClass nslParent");

        // Add Formals
        for (int i = 0; i < numFormals; i++) {
            strbuf.append(", ").append(formalTypes[i]).append(" ").append(formalNames[i]);
        }

        strbuf.append(") {").append(endLine);
        strbuf.append("\t\tsuper(nslName, nslParent");

        // Add Arguments
        for (int i = 0; i < numArguments; i++) {
            strbuf.append(", ").append(arguments[i]);
        }

        strbuf.append(");").append(endLine);

        // Add Formals init
        for (int i = 0; i < numFormals; i++) {
            strbuf.append("\t\tthis.").append(formalNames[i]).append("=").append(formalNames[i]).append(";").append(endLine);
        }

        strbuf.append("\t\tmakeInst(nslName, nslParent");

        // Add Arguments
        for (int i = 0; i < numFormals; i++) {
            strbuf.append(", ").append(formalNames[i]);
        }

        strbuf.append(");").append(endLine);
        strbuf.append("\t}").append(endLine);

        //
        // MakeInst
        //

        strbuf.append(endLine);
        strbuf.append("\tpublic void makeInst(String nslName, NslClass nslParent");

        // Add Formals
        for (int i = 0; i < numFormals; i++) {
            strbuf.append(", ").append(formalTypes[i]).append(" ").append(formalNames[i]);
        }

        strbuf.append(") { ").append(endLine);
        strbuf.append("\t\tcallFromConstructorTop();").append(endLine);

        // Put Instantiation of temporaries in makeInst
        strbuf.append(genTempInstStmt(scope));

        // Create Nsl Instances
        Vector classVarScope = scope.getClassVarScope();
        Enumeration enumer = classVarScope.elements();
        NslVariable fieldTmp;
        String instanceType;
        String instanceName;
        String instanceArguments;
        String variableInit;

        enumer = classVarScope.elements();
        while (enumer.hasMoreElements()) {
            fieldTmp = (NslVariable) enumer.nextElement();
            instanceType = fieldTmp.getType();
            instanceName = fieldTmp.getName();
            instanceArguments = fieldTmp.getArguments();

            if (fieldTmp.isNslType()) {

                variableInit = fieldTmp.getInitializers();
                instanceArguments = ((instanceArguments != null && !instanceArguments.equals("")) ? (", " + instanceArguments) : "");
                strbuf.append("\t\t").append(instanceName).append(" = new ").append(instanceType).append("(\"").append(instanceName).append("\", this").append(instanceArguments).append(");").append(endLine);
                if (variableInit != null) {
                    strbuf.append("\t\t").append(instanceName).append(".set(").append(variableInit).append(");").append(endLine);
                }
            } else if (fieldTmp.isNslArrayType()) {
                instanceType = instanceType.substring(0, instanceType.indexOf("["));
                strbuf.append("\t\t").append(instanceName).append(" = new ").append(instanceType).append(instanceArguments).append(";").append(endLine);
            }
        }

        strbuf.append("\t\tcallFromConstructorBottom();").append(endLine);

        strbuf.append("\t}").append(endLine);

        return strbuf.toString();
    }

    public void updateScope(NslScope scope) {

        NslScope subClassScope = new NslScope();

        subClassScope.setClassKind(getKind());
        subClassScope.setClassName(getClassName());

        String superClass = getSuperClass();
        subClassScope.setSuperClassName(superClass);

        ASTFormalParameters formals = (ASTFormalParameters) jjtGetChild(0);
        subClassScope.setClassFormals(formals);

        String[] types = formals.getTypes();
        String[] names = formals.getNames();

        NslVariable temp;
        for (int i = 0; i < names.length; i++) {
            if (subClassScope.isNslType(types[i])) {
                temp = new NslVariable(types[i], names[i]);
                if (!subClassScope.addLocalVar(temp)) {
                    ASTFormalParameters variable = (ASTFormalParameters) jjtGetChild(i + 1);
                    NslCompiler.printError("ASTNslNestedClassDeclaration", "Variable " + names[i] + " was already defined in this scope", variable.getFirstToken().beginLine, variable.getFirstToken().beginColumn);
                }
            }
        }

        if (inherits) {
            subClassScope.setClassArguments((ASTArguments) jjtGetChild(2));
        }

        NslScope superClassScope = NslCompiler.parseType(superClass, scope.getImportList());
        if (superClassScope != null) {
            subClassScope.setSuperClassScope(superClassScope);
        } //else {
        //NslParser.error=true;
        //System.err.println("ASTNestedClassDeclaration [Error]: Error while parsing super class "+superClass);
        //}

        subClassScope.setContainerScope(scope);

        int child = (inherits ? 3 : 1);

        NslParserVisitor visitor = new SymbolTableClassVisitor(subClassScope);
        ASTClassBody node = (ASTClassBody) jjtGetChild(child);
        node.jjtAccept(visitor, null);

        visitor = new SymbolTableVisitor(subClassScope);
        node.jjtAccept(visitor, null);
        localScope = subClassScope;

        scope.addSubClass(subClassScope);
    }

}
