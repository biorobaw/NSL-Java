/* Generated By:JJTree: Do not edit this line. ASTNslClassDeclaration.java */

/* SCCS  %W--- %G% -- %U% */

// Copyright: Copyright (c) 1997-2002 University of Southern California Brain Project.
// Copyright: This software may be freely copied provided the toplevel
// Copyright: COPYRIGHT file is included with each such copy.
// Copyright: Email nsl@java.usc.edu.

// Author: Salvador Marmol

import java.util.Enumeration;
import java.util.Vector;

@SuppressWarnings("Duplicates")
public class ASTNslClassDeclaration extends SimpleNode {

    private boolean inherits = false;
    private static String endLine = System.getProperty("line.separator");

    public ASTNslClassDeclaration(int id) {
        super(id);
    }

    public ASTNslClassDeclaration(NslParser p, int id) {
        super(p, id);
    }

    /**
     * Accept the visitor.
     **/
    public Object jjtAccept(NslParserVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }

    public void setExtends(boolean value) {
        inherits = value;
    }

    public boolean getExtends() {
        return inherits;
    }

    public String getSuperClass() {
        if (inherits) {
            ASTName nameNode = (ASTName) jjtGetChild(1);
            return nameNode.getName();
        } else {
            return "N" + getKind().substring(1);
        }
    }

    public String getClassName() {
        Token t = first.next;
        return t.image;
    }

    public String getKind() {
        Token t = first;
        return t.image;
    }

    public String toJava(NslScope scope) {

        String code = genNslImports();

        code += "public class ";
        code += getClassName();
        code += " extends " + getSuperClass();

        String nslCode = genNslCode(scope);


        first.image = code;

        int bodyIndex = (inherits ? 3 : 1);
        SimpleNode body = (SimpleNode) jjtGetChild(bodyIndex);

        first.next = body.getFirstToken();

        Token newCode = new Token();

        newCode.kind = last.kind;
        newCode.beginLine = last.beginLine;
        newCode.beginColumn = last.beginColumn;
        newCode.endLine = last.endLine;
        newCode.endColumn = last.endColumn;
        newCode.image = last.image;
        newCode.next = last.next;
        newCode.specialToken = last.specialToken;


        last.image = nslCode;
        last.next = newCode;

        //clean(first, end);

        return code;
    }

    public void updateScope(NslScope scope) {
        scope.setClassKind(getKind());
        scope.setClassName(getClassName());
        ASTFormalParameters formals = (ASTFormalParameters) jjtGetChild(0);
        scope.setClassFormals(formals);

        String[] types = formals.getTypes();
        String[] names = formals.getNames();

        NslVariable temp;
        for (int i = 0; i < names.length; i++) {
//      if (scope.isNslType(types[i])) {
            temp = new NslVariable(types[i], names[i]);
            if (!scope.addLocalVar(temp)) {
                ASTFormalParameters variable = (ASTFormalParameters) jjtGetChild(i + 1);
                NslCompiler.printError("ASTNslClassDeclaration", "Variable " + names[i] + " was already defined in this scope", variable.getFirstToken().beginLine, variable.getFirstToken().beginColumn);
            }
//      }
        }

        String superClass = getSuperClass();
        scope.setSuperClassName(superClass);
        if (inherits) {
            scope.setClassArguments((ASTArguments) jjtGetChild(2));
        }
        NslScope superClassScope = NslCompiler.parseType(superClass, scope.getImportList());
        if (superClassScope != null) {
            scope.setSuperClassScope(superClassScope);
        } //else {
        //NslParser.error=true;
        //System.err.println("ASTNslClassDeclaration [Error]: Error while parsing super class "+superClass);
        //}
    }

    String genNslImports() {
        return "/*********************************/" + endLine +
                "/*                               */" + endLine +
                "/*   Importing all Nsl classes   */" + endLine +
                "/*                               */" + endLine +
                "/*********************************/" + endLine + endLine +
                "import nslj.src.system.*;" + endLine +
                "import nslj.src.cmd.*;" + endLine +
                "import nslj.src.lang.*;" + endLine +
                "import nslj.src.math.*;" + endLine +
                "import nslj.src.display.*;" + endLine + endLine +
                "/*********************************/" + endLine + endLine;
    }

    String genNslCode(NslScope scope) {
        //    strbuf.append(genTempMethods(scope));
        return endLine +
                "\t/******************************************************/" + endLine +
                "\t/*                                                    */" + endLine +
                "\t/* Generated by NslCompiler. Do not edit these lines! */" + endLine +
                "\t/*                                                    */" + endLine +
                "\t/******************************************************/" + endLine +
                endLine +
                genConstructor(scope) +
                endLine +
                "\t/******************************************************/" + endLine +
                "\t/*                                                    */" + endLine +
                "\t/* End of automatic declaration statements.           */" + endLine +
                "\t/*                                                    */" + endLine +
                "\t/******************************************************/" + endLine +
                endLine;
    }

    String genTempDeclaration(NslScope scope) {

        StringBuilder strbuf = new StringBuilder();

        Vector tempVarList = scope.getTempVarList();
        Enumeration enumer = tempVarList.elements();
        NslVariable fieldTmp;
        String instanceType;
        String instanceName;
        while (enumer.hasMoreElements()) {
            fieldTmp = (NslVariable) enumer.nextElement();
            instanceType = fieldTmp.getType();
            instanceName = fieldTmp.getName();
            instanceType = scope.getNslTypeWithoutPort(instanceType);
            strbuf.append("\t").append(instanceType).append(" ").append(instanceName).append(";").append(endLine);
        }
        return strbuf.toString();
    }

    String genTempInstStmt(NslScope scope) {

        StringBuilder strbuf = new StringBuilder();

        Vector tempVarList = scope.getTempVarList();
        Enumeration enumer = tempVarList.elements();
        NslVariable fieldTmp;
        String instanceType;
        String instanceName;
        String instanceArguments;
        String staticType = "";
        boolean isNsl;

        while (enumer.hasMoreElements()) {
            fieldTmp = (NslVariable) enumer.nextElement();
            instanceType = fieldTmp.getType();
            instanceName = fieldTmp.getName();
            instanceArguments = "";
            if (instanceType.contains("static ")) {
                instanceType = instanceType.substring(7);
                staticType = "static ";
            }
            isNsl = scope.isNslType(instanceType);
            if (isNsl) {
                instanceType = scope.getNslTypeWithoutPort(instanceType);
                switch (scope.getNslTypeDim(instanceType)) {
                    case 1:
                        instanceArguments = "1";
                        break;
                    case 2:
                        instanceArguments = "1, 1";
                        break;
                    case 3:
                        instanceArguments = "1, 1, 1";
                        break;
                    case 4:
                        instanceArguments = "1, 1, 1, 1";
                        break;
                }
                strbuf.append("\t\t").append(staticType).append(instanceType).append(" ").append(instanceName).append(" = new ").append(instanceType).append("(").append(instanceArguments).append(");").append(endLine);
            } else {
                int dim = scope.getDim(instanceType);
                switch (dim) {
                    case 1:
                        instanceArguments = "[1]";
                        break;
                    case 2:
                        instanceArguments = "[1][1]";
                        break;
                    case 3:
                        instanceArguments = "[1][1][1]";
                        break;
                    case 4:
                        instanceArguments = "[1][1][1][1]";
                        break;
                }
                if (dim > 0) {
                    String newInstanceType = instanceType.substring(0, instanceType.indexOf("["));
                    strbuf.append("\t\t").append(staticType).append(instanceType).append(" ").append(instanceName).append(" = new ").append(newInstanceType).append(instanceArguments).append(";").append(endLine);
                }
            }
        }
        return strbuf.toString();
    }

    String genTempMethods(NslScope scope) {

        StringBuilder strbuf = new StringBuilder();

        String kind = getKind();

        if (kind.equals("nslClass")) {
            strbuf.append("\t/* nslInitTempClass inserted by NPP */").append(endLine);
            strbuf.append("\tpublic void nslInitTempClass() {").append(endLine);
            //    strbuf.append(genModInitStmt()); ?
            strbuf.append("\t}").append(endLine).append(endLine);
        } else {
            strbuf.append("\t/* nslInitTempModule inserted by NslCompiler */").append(endLine);
            strbuf.append("\tpublic void nslInitTempModule() {").append(endLine);
            // Temporaries instantiated in this method only if its nslModule or
            // nslModel, otherwise they are instantiated in makeInst
            //    strbuf.append(genTempInstStmt());
            //    strbuf.append(genModInitStmt());
            strbuf.append("\t}").append(endLine).append(endLine);

            strbuf.append("\t/* nslInitTempRun inserted by NslCompiler */").append(endLine);
            strbuf.append("\tpublic void nslInitTempRun() {").append(endLine);
            //    strbuf.append(genRunInitStmt());
            strbuf.append("\t}").append(endLine).append(endLine);

            strbuf.append("\t/* nslInitTempTrain inserted by NslCompiler */").append(endLine);
            strbuf.append("\tpublic void nslInitTempTrain() {").append(endLine);
            //    strbuf.append(genTrainInitStmt());
            strbuf.append("\t}").append(endLine).append(endLine);
        }
        return strbuf.toString();
    }

    String genConstructor(NslScope scope) {

        StringBuilder strbuf = new StringBuilder();

        strbuf.append("\t/* Constructor and related methods */").append(endLine);
        strbuf.append("\t/* makeinst() declared variables */").append(endLine);

        String kind = getKind();
        String name = getClassName();
        String newName = name.substring(0, 1).toLowerCase() + name.substring(1);
        String superClass = getSuperClass();

        ASTFormalParameters formals = scope.getClassFormals();
        String[] formalTypes = formals.getTypes();
        String[] formalNames = formals.getNames();
        int numFormals = formalTypes.length;

        ASTArguments argumentsNode = scope.getClassArguments();

        String[] arguments = null;
        int numArguments;
        if (argumentsNode != null) {
            arguments = argumentsNode.getArguments();
            numArguments = arguments.length;
        } else {
            numArguments = 0;
        }

        //
        // nslModel Constructor
        //

        if (kind.equals("nslModel")) {

            strbuf.append(endLine);
            strbuf.append("\t/* EMPTY CONSTRUCTOR: Called only for the top level module */").append(endLine);
            strbuf.append("\tpublic ").append(name).append("() {").append(endLine);
            strbuf.append("\t\tsuper(\"").append(newName).append("\",(").append(superClass).append(")null);").append(endLine);
            strbuf.append("\t\tif (NslMain.TopLoaded) {").append(endLine);
            strbuf.append("\t\t    System.err.println(\"ERROR: construction without (name,parent)\");").append(endLine);
            strbuf.append("\t\t    System.exit(1);").append(endLine);
            strbuf.append("\t\t}").append(endLine);
            strbuf.append("\t\tNslMain.TopLoaded=true; ").append(endLine);
            strbuf.append("\t\tinitSys();").append(endLine);                 // Call initSys
            strbuf.append("\t\tmakeInst(\"").append(newName).append("\",null);").append(endLine);    // Call makeInst
            strbuf.append("\t}").append(endLine);
        }  // end of Empty Constructor

        //
        // Formal Declaration
        //

        strbuf.append(endLine);
        strbuf.append("\t/* Formal parameters */").append(endLine);

        //  Add Formals
        for (int i = 0; i < numFormals; i++) {
            strbuf.append("\t").append(formalTypes[i]).append(" ").append(formalNames[i]).append(";").append(endLine);
        }


        //
        // Temporary Variables Declaration
        //

        strbuf.append(endLine);
        strbuf.append("\t/* Temporary variables */").append(endLine);

        //  Add Temporaries
        //    strbuf.append(genTempDeclaration(scope));
        strbuf.append(genTempInstStmt(scope));
        //
        // Generic Constructor
        //

        strbuf.append(endLine);
        strbuf.append("\t/* GENERIC CONSTRUCTOR: */").append(endLine);
        strbuf.append("\tpublic ").append(name).append("(String nslName, NslModule nslParent");

        //  Add Formals
        for (int i = 0; i < numFormals; i++) {
            strbuf.append(", ").append(formalTypes[i]).append(" ").append(formalNames[i]);
        }

        strbuf.append(") {").append(endLine);
        strbuf.append("\t\tsuper(nslName, nslParent");

        //  Add Arguments
        for (int i = 0; i < numArguments; i++) {
            strbuf.append(", ").append(arguments[i]);
        }

        strbuf.append(");").append(endLine);

        //  Add Formals init
        for (int i = 0; i < numFormals; i++) {
            strbuf.append("\t\tthis.").append(formalNames[i]).append("=").append(formalNames[i]).append(";").append(endLine);
        }

        if (!kind.equals("nslClass")) {
            strbuf.append("\t\tinitSys();").append(endLine);   // Call initSys
        }

        strbuf.append("\t\tmakeInst(nslName, nslParent");

        //  Add Arguments
        for (int i = 0; i < numFormals; i++) {
            strbuf.append(", ").append(formalNames[i]);
        }

        strbuf.append(");").append(endLine);
        strbuf.append("\t}").append(endLine);

        //
        // nslClass Constructor
        //

        if (kind.equals("nslClass")) {
            strbuf.append(endLine);
            //      strbuf.append("\tpublic void callFromConstructorBottom() {}"+endLine);
            //      strbuf.append("\tpublic void callFromConstructorTop() {}"+endLine);

            strbuf.append(endLine);
            strbuf.append("\tpublic ").append(name).append("(String nslName, NslClass nslParent");

            // Add Formals
            for (int i = 0; i < numFormals; i++) {
                strbuf.append(", ").append(formalTypes[i]).append(" ").append(formalNames[i]);
            }

            strbuf.append(") {").append(endLine);
            strbuf.append("\t\tsuper(nslName, nslParent");

            // Add Arguments
            for (int i = 0; i < numArguments; i++) {
                strbuf.append(", ").append(arguments[i]);
            }

            strbuf.append(");").append(endLine);

            // Add Formals init
            for (int i = 0; i < numFormals; i++) {
                strbuf.append("\t\tthis.").append(formalNames[i]).append("=").append(formalNames[i]).append(";").append(endLine);
            }

            strbuf.append("\t\tmakeInst(nslName, nslParent");

            // Add Arguments
            for (int i = 0; i < numFormals; i++) {
                strbuf.append(", ").append(formalNames[i]);
            }

            strbuf.append(");").append(endLine);
            strbuf.append("\t}").append(endLine);
        }


        //
        // MakeInst
        //

        strbuf.append(endLine);
        strbuf.append("\tpublic void makeInst(String nslName, NslModule nslParent");

        // Add Formals
        for (int i = 0; i < numFormals; i++) {
            strbuf.append(", ").append(formalTypes[i]).append(" ").append(formalNames[i]);
        }

        strbuf.append(") { ").append(endLine);
        strbuf.append("\t\tcallFromConstructorTop();").append(endLine);

        // Put Instantiation of temporaries in makeInst if its nslClass
        //    if (kind.equals("nslClass")) {
        //    strbuf.append(genTempInstStmt(scope));
        //    }

        // Create Nsl Instances

        Vector classVarScope = scope.getClassVarScope();
        Enumeration enumer = classVarScope.elements();
        NslVariable fieldTmp;
        String instanceType;
        String instanceName;
        String instanceArguments;
        String variableInit;

        while (enumer.hasMoreElements()) {
            fieldTmp = (NslVariable) enumer.nextElement();
            instanceType = fieldTmp.getType();
            instanceName = fieldTmp.getName();
            instanceArguments = fieldTmp.getArguments();

            if (fieldTmp.isNslType()) {

                variableInit = fieldTmp.getInitializers();
                instanceArguments = ((instanceArguments != null && !instanceArguments.equals("")) ? (", " + instanceArguments) : "");
                strbuf.append("\t\t").append(instanceName).append(" = new ").append(instanceType).append("(\"").append(instanceName).append("\", this").append(instanceArguments).append(");").append(endLine);
                if (variableInit != null) {
                    strbuf.append("\t\t").append(instanceName).append(".set(").append(variableInit).append(");").append(endLine);
                }
            } else if (fieldTmp.isNslArrayType()) {
                instanceType = instanceType.substring(0, instanceType.indexOf("["));
                strbuf.append("\t\t").append(instanceName).append(" = new ").append(instanceType).append(instanceArguments).append(";").append(endLine);
            }
        }

        strbuf.append("\t\tcallFromConstructorBottom();").append(endLine);

        strbuf.append("\t}").append(endLine);

        //
        // nslClass makeInst
        //

        if (kind.equals("nslClass")) {
            strbuf.append(endLine);
            strbuf.append("\tpublic void makeInst(String nslName, NslClass nslParent");

            // Add Formals
            for (int i = 0; i < numFormals; i++) {
                strbuf.append(", ").append(formalTypes[i]).append(" ").append(formalNames[i]);
            }

            strbuf.append(") { ").append(endLine);
            strbuf.append("\t\tcallFromConstructorTop();").append(endLine);

            // Put Instantiation of temporaries in makeInst
            //      strbuf.append(genTempInstStmt(scope));

            // Create Nsl Instances

            enumer = classVarScope.elements();
            while (enumer.hasMoreElements()) {
                fieldTmp = (NslVariable) enumer.nextElement();
                instanceType = fieldTmp.getType();
                instanceName = fieldTmp.getName();
                instanceArguments = fieldTmp.getArguments();

                if (fieldTmp.isNslType()) {

                    variableInit = fieldTmp.getInitializers();
                    instanceArguments = ((instanceArguments != null && !instanceArguments.equals("")) ? (", " + instanceArguments) : "");
                    strbuf.append("\t\t").append(instanceName).append(" = new ").append(instanceType).append("(\"").append(instanceName).append("\", this").append(instanceArguments).append(");").append(endLine);
                    if (variableInit != null) {
                        strbuf.append("\t\t").append(instanceName).append(".set(").append(variableInit).append(");").append(endLine);
                    }
                } else if (fieldTmp.isNslArrayType()) {
                    instanceType = instanceType.substring(0, instanceType.indexOf("["));
                    strbuf.append("\t\t").append(instanceName).append(" = new ").append(instanceType).append(instanceArguments).append(";").append(endLine);
                }
            }

            strbuf.append("\t\tcallFromConstructorBottom();").append(endLine);

            strbuf.append("\t}").append(endLine);
        }

        return strbuf.toString();
    }


    public String toXMLOpen(String prefix) {
        String kind = getKind();
        String name = getClassName();
        return prefix + "<" + toString() + " kind=\"" + kind + "\" name=\"" + name + "\">";
    }

}
