/* Generated By:JJTree: Do not edit this line. ASTPrimaryExpression.java */

/* SCCS  %W--- %G% -- %U% */

// Copyright: Copyright (c) 1997-2002 University of Southern California Brain Project.
// Copyright: This software may be freely copied provided the toplevel
// Copyright: COPYRIGHT file is included with each such copy.
// Copyright: Email nsl@java.usc.edu.

// Author: Salvador Marmol

@SuppressWarnings("Duplicates")
public class ASTPrimaryExpression extends ASTExpression {

    public ASTPrimaryExpression(int id) {
        super(id);
    }

    public ASTPrimaryExpression(NslParser p, int id) {
        super(p, id);
    }

    public String getExpressionType() {
        return expressionType;
    }

    /**
     * Accept the visitor.
     **/
    public Object jjtAccept(NslParserVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }

    public int getNextState(int previousState, String name) {
        int nextState = -1;
        switch (previousState) {
            case 0: // this
                if (name.equals("access")) {
                    nextState = 5;
                } else if (name.equals(".super")) {
                    nextState = 6;
                }
                break;
            case 1: // super.
                // Super class access
                break;
            case 2: // "(" Expression ")"
                switch (name) {
                    case "access":
                        nextState = 5;
                        break;
                    case "index":
                        nextState = 9;
                        break;
                    case ".super":
                        nextState = 6;
                        break;
                }
                break;
            case 3: // Name
                if (name.equals("index")) {
                    nextState = 9;
                } else if (name.equals("method")) {
                    nextState = 7;
                }
                break;
            case 4: // Index
                if (name.equals("index")) {
                    nextState = 4;
                } else if (name.equals("access")) {
                    nextState = 8;
                }
                break;
            case 5: // Access
                switch (name) {
                    case "access":
                        nextState = 5;
                        break;
                    case "index":
                        nextState = 9;
                        break;
                    case "method":
                        nextState = 7;
                        break;
                }
                break;
            case 6: // .super
                if (name.equals("access")) {
                    nextState = 5;
                }
                break;
            case 7: // Method
                if (name.equals("access")) {
                    nextState = 5;
                } else if (name.equals("index")) {
                    nextState = 9;
                }
                break;
            case 8: // construct index
                nextState = 5;
                break;
            case 9: // start index
                nextState = 4;
                break;
        }
        return nextState;
    }

    public void generateIndexCode(Token start, Token end, SimpleNode parentExpression,
                                  ASTPrimarySuffix[] indexNodes, int indexNum, NslScope scope, String currentType) {

        if (!nslExpression) {
            return;
        }

        boolean isAssignment = parentExpression.isNodeOfType("assignment");
        String ext = (isAssignment ? ".set(" : ".get(");

        if (isAssignment) {
            start.image += ext;
            indexNodes[0].removeBraces("", ", ");
            for (int j = 1; j < indexNum; j++) {
                indexNodes[j].removeBraces("", ", ");
            }
        } else {
            String wrap = "))";
            //      if (scope.getDim(currentType)>0) {
            String temp = scope.getTempName(currentType);
            start.image = temp + ".setReference(" + start.image + ext;
            //      } else {
            //        start.image = start.image + ext;
            //	wrap=")";
            //      }
            indexNodes[0].removeBraces("", "");
            for (int j = 1; j < indexNum; j++) {
                indexNodes[j].removeBraces(", ", "");
            }
            if (end.image.equals(".")) {
                end.image = wrap + end.image;
            } else {
                end.image += wrap;
            }
        }

    }

    public boolean isNslExpression() {
        return nslExpression;
    }

    SimpleNode currentOper;

    public String getNewType(NslScope scope, String type, int indexNum) {
        if (scope.isNslType(type)) {
            int dim = scope.getNslTypeDim(type);
            dim = dim - indexNum;
            if (dim >= 0 && dim <= 4) {
                type = type.substring(0, type.length() - 1) + dim;
            } else {
                NslCompiler.printError("ASTPrimaryExpression", "An array is required to use the \"[]\" operator", currentOper.getFirstToken().beginLine, currentOper.getFirstToken().beginColumn);
            }
        } else if (isArray) {
            int dim = scope.getArrayDim(type);
            dim = dim - indexNum;
            if (dim >= 0 && dim <= 4) {
                StringBuilder temp = new StringBuilder();
                for (int i = 0; i < dim; i++) {
                    temp.append("[]");
                }
                type = type.substring(0, type.indexOf("[")) + temp;
            } else {
                NslCompiler.printError("ASTPrimaryExpression", "An array is required to use the \"[]\" operator", currentOper.getFirstToken().beginLine, currentOper.getFirstToken().beginColumn);
            }
        }
        return type;
    }

    boolean isArray = false, isMethod = false, isAccess = false;

    public String toJava(NslScope scope) {

        int childNum = jjtGetNumChildren();

        ASTPrimaryPrefix prefixNode = (ASTPrimaryPrefix) (currentOper = (SimpleNode) jjtGetChild(0));

        int oldState, state;
        String currentType;

        if (prefixNode.isNodeOfType("this")) {
            currentType = expressionType = scope.getClassName();
            isAccess = true;
            state = 0;
        } else if (prefixNode.isNodeOfType("super.")) {
            currentType = expressionType = scope.getSuperClassName();
            isAccess = true;
            state = 1;
        } else if (prefixNode.isNodeOfType("expression")) {
            currentType = expressionType = prefixNode.getType();
            nslExpression = prefixNode.isNslExpression();
            isArray = scope.isArray(expressionType);
            state = 2;
        } else if (prefixNode.isNodeOfType("name")) {
            currentType = expressionType = prefixNode.getType();
            nslExpression = prefixNode.isNslExpression();
            isArray = scope.isArray(expressionType);
            isMethod = prefixNode.isMethodName();
            state = 3;
        } else if (prefixNode.isNodeOfType("literal")) {
            currentType = expressionType = prefixNode.getType();
            return "";
        } else {
            return "";
        }

        if (!nslExpression && !isArray && !isMethod && !isAccess) {
            return "";
        }

        SimpleNode parentExpression = findParentExpression((SimpleNode) parent);

        if (parentExpression == null) {
            NslCompiler.printError("ASTPrimaryExpression", "Compiler bug. An invalid AST was formed");
            return "";
        }

        if (nslExpression && childNum == 1 && state == 3) {
            // A Nsl LHS variable
            String ext = (parentExpression.isNodeOfType("assignment") ? ".set(" : "");
            return first.image = first.image + ext;
        }

        int indexNum = 0;
        ASTPrimarySuffix[] indexNodes = new ASTPrimarySuffix[childNum - 1];
        ASTPrimarySuffix tempNode = null;
        Token start = first, end = last;
        NslScope methodScope = (isMethod ? prefixNode.getMethodScope() : null);
        String methodName = (isMethod ? prefixNode.getMethodName() : null);
        String[] arguments;
        String variableName;
        for (int i = 1; i < childNum; i++) {
            currentOper = tempNode = (ASTPrimarySuffix) jjtGetChild(i);
            oldState = state;
            state = getNextState(oldState, tempNode.getNodeType());
            switch (state) {
                case -1:
                    NslCompiler.printError("ASTPrimaryExpression", "Invalid state was reached in expression.", currentOper.getFirstToken().beginLine, currentOper.getFirstToken().beginColumn);
                    return "";
                case 7:
                    if (methodScope != null) {
                        arguments = tempNode.getArgumentsTypes();
                        NslMethod method = methodScope.resolveMethod(methodName, arguments);
                        if (method != null) {
                            currentType = expressionType = method.getType();
                            nslExpression = scope.isNslType(currentType);
                            isArray = scope.isArray(currentType);
                        } else {
                            StringBuilder error = new StringBuilder("Couldn't find method " + methodScope.getClassName() + "." + methodName + "(");
                            for (int j = 0; j < arguments.length; j++) {
                                error.append((j > 0) ? ", " : "").append(arguments[j]);
                            }
                            error.append(") in class ").append(scope.getClassName());
                            NslCompiler.printError("ASTPrimaryExpression", error.toString(), currentOper.getFirstToken().beginLine, currentOper.getFirstToken().beginColumn);
                            return "";
                        }
                    }
                    break;
                case 5:
                    variableName = tempNode.getVariableName();

                    if (currentType.contains("[")) {
                        if (!variableName.equals("length")) {
                            NslCompiler.printError("ASTPrimaryExpression", "Type " + currentType + " is an array. Trying to access something different than length", currentOper.getFirstToken().beginLine, currentOper.getFirstToken().beginColumn);
                            return "";
                        } else {
                            currentType = expressionType = "int";
                            break;
                        }
                    }
                    NslScope localScope = scope.resolveClass(currentType);
                    if (localScope == null) {
                        NslCompiler.printError("ASTPrimaryExpression", "Type " + currentType + " was not found", currentOper.getFirstToken().beginLine, currentOper.getFirstToken().beginColumn);
                        return "";
                    }
                    NslVariable temp = localScope.resolveVar(variableName);
                    if (temp == null) {
                        // check if it is a function name
                        NslMethod method = localScope.resolveMethod(variableName);
                        if (method == null) {
                            NslCompiler.printError("ASTPrimaryExpression", "Variable " + variableName + " was not found in class " + localScope.getClassName(), currentOper.getFirstToken().beginLine, currentOper.getFirstToken().beginColumn);
                            return "";
                        } else {
                            methodName = variableName;
                            methodScope = localScope;
                            isMethod = true;
                        }
                    } else {
                        currentType = expressionType = temp.getType();
                        nslExpression = scope.isNslType(currentType);
                        String tempType = currentType;
                        if (currentType.contains("[")) {
                            currentType = currentType.substring(0, currentType.indexOf("["));
                        }
                        if (scope.isPrimitive(tempType)) {
                            NslCompiler.parseType(tempType, scope.getImportList());
                        }
                    }

                    break;
                case 8:
                    end = tempNode.getFirstToken();
                    currentType = expressionType = getNewType(scope, currentType, indexNum);
                    generateIndexCode(start, end, parentExpression, indexNodes, indexNum, scope, currentType);
                    state = 5;
                    break;
                case 9:
                    indexNum = 0;
                    start = ((SimpleNode) jjtGetChild(i - 1)).getLastToken();
                case 4:
                    indexNodes[indexNum++] = tempNode;
                    state = 4;
                    break;
            }
        }

        if (state == 4) {
            if (tempNode != null) {
                end = tempNode.getFirstToken();
            }
            currentType = expressionType = getNewType(scope, currentType, indexNum);
            generateIndexCode(start, end, parentExpression, indexNodes, indexNum, scope, currentType);
        }

        return "";
    }

    public String computeType(NslScope scope) {

        int childNum = jjtGetNumChildren();

        ASTPrimaryPrefix prefixNode = (ASTPrimaryPrefix) (currentOper = (SimpleNode) jjtGetChild(0));

        int oldState, state;
        String currentType;

        if (prefixNode.isNodeOfType("this")) {
            currentType = expressionType = scope.getClassName();
            isAccess = true;
            state = 0;
        } else if (prefixNode.isNodeOfType("super.")) {
            currentType = expressionType = scope.getSuperClassName();
            isAccess = true;
            state = 1;
        } else if (prefixNode.isNodeOfType("expression")) {
            currentType = expressionType = prefixNode.getType();
            nslExpression = prefixNode.isNslExpression();
            isArray = scope.isArray(expressionType);
            state = 2;
        } else if (prefixNode.isNodeOfType("name")) {
            currentType = expressionType = prefixNode.getType();
            nslExpression = prefixNode.isNslExpression();
            isArray = scope.isArray(expressionType);
            isMethod = prefixNode.isMethodName();
            state = 3;
        } else if (prefixNode.isNodeOfType("literal")) {
            currentType = expressionType = prefixNode.getType();
            return "";
        } else {
            return "";
        }

        if (!nslExpression && !isArray && !isMethod && !isAccess) {
            return "";
        }

        SimpleNode parentExpression = findParentExpression((SimpleNode) parent);

        if (parentExpression == null) {
            NslCompiler.printError("ASTPrimaryExpression", "Compiler bug. An invalid AST was formed");
            return "";
        }

        if (nslExpression && childNum == 1 && state == 3) {
            // A Nsl LHS variable
            String ext = (parentExpression.isNodeOfType("assignment") ? ".set(" : "");
            return "";
        }

        int indexNum = 0;
        ASTPrimarySuffix[] indexNodes = new ASTPrimarySuffix[childNum - 1];
        ASTPrimarySuffix tempNode = null;
        Token start = first, end = last;
        NslScope methodScope = (isMethod ? prefixNode.getMethodScope() : null);
        String methodName = (isMethod ? prefixNode.getMethodName() : null);
        String[] arguments;
        String variableName;
        for (int i = 1; i < childNum; i++) {
            currentOper = tempNode = (ASTPrimarySuffix) jjtGetChild(i);

            oldState = state;
            state = getNextState(oldState, tempNode.getNodeType());
            switch (state) {
                case -1:
                    NslCompiler.printError("ASTPrimaryExpression", "Invalid state was reached in expression.", currentOper.getFirstToken().beginLine, currentOper.getFirstToken().beginColumn);
                    return "";
                case 7:
                    if (methodScope != null) {
                        arguments = tempNode.getArgumentsTypes();
                        NslMethod method = methodScope.resolveMethod(methodName, arguments);
                        if (method != null) {
                            currentType = expressionType = method.getType();
                            if (i > 1) {
                                ASTPrimarySuffix oldNode = (ASTPrimarySuffix) jjtGetChild(i - 1);
                                oldNode.setType(expressionType);
                                oldNode.setMethod(true);
                            }
                            nslExpression = scope.isNslType(currentType);
                            isArray = scope.isArray(currentType);
                        } else {
                            StringBuilder error = new StringBuilder("Couldn't find method " + methodScope.getClassName() + "." + methodName + "(");
                            for (int j = 0; j < arguments.length; j++) {
                                error.append((j > 0) ? ", " : "").append(arguments[j]);
                            }
                            error.append(") in class ").append(scope.getClassName());
                            NslCompiler.printError("ASTPrimaryExpression", error.toString(), currentOper.getFirstToken().beginLine, currentOper.getFirstToken().beginColumn);
                            return "";
                        }
                    }
                    break;
                case 5:
                    variableName = tempNode.getVariableName();

                    if (currentType.contains("[")) {
                        if (!variableName.equals("length")) {
                            NslCompiler.printError("ASTPrimaryExpression", "Type " + currentType + " is an array. Trying to access something different than length", currentOper.getFirstToken().beginLine, currentOper.getFirstToken().beginColumn);
                            return "";
                        } else {
                            currentType = expressionType = "int";
                            tempNode.setType(expressionType);
                            break;
                        }
                    }
                    NslScope localScope = scope.resolveClass(currentType);

                    if (localScope == null) {
                        NslCompiler.printError("ASTPrimaryExpression", "Type " + currentType + " was not found", currentOper.getFirstToken().beginLine, currentOper.getFirstToken().beginColumn);
                        return "";
                    }
                    NslVariable temp = localScope.resolveVar(variableName);
                    if (temp == null) {
                        // check if it is a function name
                        NslMethod method = localScope.resolveMethod(variableName);
                        if (method == null) {
                            NslCompiler.printError("ASTPrimaryExpression", "Variable " + variableName + " was not found in class " + localScope.getClassName(), currentOper.getFirstToken().beginLine, currentOper.getFirstToken().beginColumn);
                            return "";
                        } else {
                            methodName = variableName;
                            methodScope = localScope;
                            isMethod = true;
                        }
                    } else {
                        currentType = expressionType = temp.getType();
                        tempNode.setType(expressionType);
                        nslExpression = scope.isNslType(currentType);
                        String tempType = currentType;
                        if (currentType.contains("[")) {
                            currentType = currentType.substring(0, currentType.indexOf("["));
                        }
                        if (scope.isPrimitive(tempType)) {
                            NslCompiler.parseType(tempType, scope.getImportList());
                        }
                    }

                    break;
                case 8:
                    currentType = expressionType = getNewType(scope, currentType, indexNum);
                    tempNode.setType(expressionType);
                    state = 5;
                    break;
                case 9:
                    indexNum = 0;
                    start = ((SimpleNode) jjtGetChild(i - 1)).getLastToken();
                case 4:
                    indexNodes[indexNum++] = tempNode;
                    state = 4;
                    break;
            }
        }

        if (state == 4) {
            currentType = expressionType = getNewType(scope, currentType, indexNum);
            tempNode.setType(expressionType);
        }

        prefixNode.setType(expressionType);

        return "";
    }


    private SimpleNode findParentExpression(SimpleNode node) {
        if (node.getClass().getName().equals("ASTExpression") || node instanceof ASTStatementExpression) {
            return node;
        } else if (node.parent != null) {
            return findParentExpression((SimpleNode) node.parent);
        } else {
            return null;
        }
    }

}
