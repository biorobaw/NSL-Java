/* This file is generated by  NSL3.0 preprocessor*/

/* SCCS  %W%---%G%--%U% */
/* old kversion @(#)VISINPUT.mod	1.8 --- 08/05/99 -- 13:56:48 : jversion  @(#)VISINPUT.mod	1.2---04/23/99--18:32:55 */

 import nslj.src.system.*; 
 import nslj.src.cmd.*; 
 import nslj.src.lang.*; 
 import nslj.src.math.*; 
 import nslj.src.display.*; 
/* verbatim NSLJ */
import java.lang.*;
import java.util.*;
 /* verbatim off */

// VISINPUT
/* 
* Here is the class representing the input module from s.C.
* In old NSL it is an input array, but since NSLJ does not have
* input arrays yet we make them static arrays.
*/

 public class VISINPUT extends NslModule/*(int array_size)*/ {
//outputs
    public NslDoutDouble2 visinput_out ; /*(array_size,array_size)*/

//privates
  static  private  int NINE = 9;
  static  private  double retinatm  = 0.004;

  private  Illuminations InputIlluminations;
  private  int cycle =0;

  private  NslDouble2 retina ; /*(array_size,array_size)  */

public  void initModule(){
	/* verbatim NSLJ */
    InputIlluminations=new Illuminations();
	 /* verbatim off */
}

public  void initRun(){
    visinput_out.set(0);
    retina.set(0);
    cycle =0;

/** for demo purpose only */
/* Commented out Illuminations in initRun() (JS 10/14/97) */
/*
    Illumination ve;
    Illumination (4,4,0,0.0,0.2) ve  ;
    InputIlluminations.getIlluminationList().addElement(ve);
    Illumination (0,0,60,0.050,0.150) ve  ;
    InputIlluminations.getIlluminationList().addElement(ve);
    Illumination (2,1,60,0.100,0.200) ve  ;
    InputIlluminations.getIlluminationList().addElement(ve);
*/

	// 96/12/20 aa
	//System.out.println("InputIlluminations:\n" + InputIlluminations+"\n");

}

 public  void simRun(){
  // System.err.println("@@@@ VISINPUT simRun entered @@@@");
/*
    CurrentTime = rint( ( SACCADE.get_time() * 10000.0 ));
    CurrentTime = CurrentTime / 10000.0;

    System.out.println("Time: "+ setprecision(4) + setw(8) + CurrentTime);
*/

    CheckInput( visinput_out, InputIlluminations );
    retina.set(system.nsldiff.eval(retina,retinatm,
 __nsltmp102=nslj.src.math.NslAdd.eval(__nsltmp102,
 __nsltmp101=nslj.src.math.NslSub.eval(__nsltmp101,0,retina.get()),visinput_out.get()))) /* rule 108 */;

	// 96/12/20 aa
	cycle=cycle+1;
//	nslprintln("cycle " + cycle);  took out Jan 21 1998 - aa
//	System.out.println("visinput_out " + visinput_out);

}
  
// Allow manipulation of events (JS 10/9/97)
public  void resetIlluminations(){
    InputIlluminations.getIlluminationList().removeAllElements();
}

public  void addIllumination(int x, int y, double act, double ts, double te){
    InputIlluminations.getIlluminationList().addElement(new Illumination(x,y,act,ts,te));
}

//This function processes the visual events established for the current
//experiment at the start of each time step.  If a new visual event has
//started, the appropriate matrix element in visinput is activated.  If a
//visual event has expired, the corresponding visinput element is set to 0.

public  NslDouble2 CheckInput(NslDouble2 visinput, Illuminations events) {
     double cur_time = 0;
     Illumination cur;
     int i;
     Enumeration e;

    cur_time=system.getCurTime()/* rule 102*/;
    e=events.getIlluminationList().elements()/* rule 102*/;

    while (e.hasMoreElements()) {
 //      Check start time for an event
     cur=(Illumination)e.nextElement()/* rule 112 */;
      if (cur_time >= cur.getStart()) {
//          Set visinput array element to event activation value
	(visinput).set(cur.getX(),cur.getY(),(0)+(cur.getValue()));
      }

      if (cur_time >=cur.getStop()) {
//          Illumination is done, set visinput element to 0
	(visinput).set(cur.getX(),cur.getY(),0.0);
      }
    }

     return visinput;
  }
	/* nslInitTempModule inserted by NPP */
public void nslInitTempModule() {
	/* Instantiation statements generated by NslPreProcessor */
	/* temporary variables */
	__nsltmp101 = new double[1][1];
	__nsltmp102 = new double[1][1];
	/* end of automatic instantiation statements */
	/* Intialisation statements generated by NslPreProcessor */
	/* temporary variables */
	/* end of automatic intialisation statements */
}

	/* nslInitTempRun inserted by NPP */
public void nslInitTempRun() {
	/* Intialisation statements generated by NslPreProcessor */
	/* temporary variables */
	for (int i = 0; i < __nsltmp101.length; i++) {
		for (int j = 0; j < __nsltmp101[0].length; j++) {
			__nsltmp101[i][j] = 0;
		}
	}
	for (int i = 0; i < __nsltmp102.length; i++) {
		for (int j = 0; j < __nsltmp102[0].length; j++) {
			__nsltmp102[i][j] = 0;
		}
	}
	/* end of automatic intialisation statements */
}

	/* nslInitTempTrain inserted by NPP */
public void nslInitTempTrain() {
	/* Initialisation statements generated by NslPreProcessor */
	/* temporary variables */
	/* end of automatic intialisation statements */
}

	/* Declaration statements generated by NslPreProcessor */
	/* makeinst() declared variables */
	/* temporary variables */
	private  double[][] __nsltmp101;
	private  double[][] __nsltmp102;
	/* constructor and related methods */
	/* nsl declarations */
	int array_size;

	 /*GENERIC CONSTRUCTOR:   */
	 public VISINPUT(String nslName, NslModule nslParent,int array_size) {
		super(nslName, nslParent);
		this.array_size = array_size;
		initSys();
		makeInst(nslName, nslParent,array_size);
	}
	public void makeInst(String nslName, NslModule nslParent,int array_size){ 
	 visinput_out=new NslDoutDouble2 ("visinput_out",this,array_size,array_size); //NSLDECLS 
	 retina=new NslDouble2 ("retina",this,array_size,array_size); //NSLDECLS 
	}
	/* end of automatic declaration statements */
} //end class
