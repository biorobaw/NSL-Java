/* This file is generated by  NSL3.0 preprocessor*/

/* SCCS %W%---%G%--%U% */

/* Copyright 1999 University of Southern California Brain Lab */
/* Author Jacob Spoelstra */
/* email nsl@java.usc.edu */

SPECIAL nslImport nslAllImports;

NSLJ nslModule PC_layer() {
    // constants
    static final SPECIAL double f_max  = 100.;
    static final SPECIAL double offset = 750.; // output +- 5 for 0 input
    static final SPECIAL double slope  = .005;
    // inports
    NslDinDouble2 gc_in();   // GC input
    NslDinDouble1 io_in();   // IO input
    // outports
    NslDoutDouble2 pc_out(2,5); 
    // variables
    NslDouble1 w(3000);
    NslDouble2 pc_mp(2,5);
    NslDouble0 alpha();

 public NSLJ void initModule(){
     alpha = (NslDouble0)nslGetValue("dartModel.alpha");
     
     // Initialize weights
     w = nslAdd(20./((30.*30.)/3.) , nslElemDiv(nslRandom(w,-.5,.5),2));
     pc_out = 5.;
     pc_mp = 0.;
 }
 
 public NSLJ void simTrain() {
     simRun();
 }
 
 public NSLJ void endTrain() {
     endRun();
 }

 public NSLJ void simRun(){
     processGCInputs(false);   
     // Update PC cells
     pc_out = f_max * nslSigmoid(pc_mp,slope,offset);
 }

 public NSLJ void endRun() {
     // Learning
     processGCInputs(true);
     w = nslBound(w,0, 1, 0, 1);
 }

 private NSLJ void processGCInputs(boolean endEpoch) {
     SPECIAL int px,py,gx,gy,y,wc;
     SPECIAL int beam_start;
     SPECIAL int i,j;
     // GC inputs
     pc_mp = 0.;
     wc = 0;
     for(px=0;px<2;px++){
	 for(py=0;py<5;py++){
	     beam_start = py*30/5;
	     for(gx=0;gx<30;gx++){
		 for(y=0;y<10;y++){
		     gy = (beam_start + y)%30;
	             if (!endEpoch) {
		         pc_mp[px][py] = pc_mp[px][py] 
			     + w[wc] * gc_in[gx][gy];
		     } else {
			w[wc] = w[wc]
			     + alpha * (gc_in[gx][gy]*.01) * (io_in[px] - 2.);
		     }
		     wc++;
		 }
	     }
	 }
     }
 }
 
}