<HTML>
<HEAD>
<TITLE>Dominey-Arbib README </TITLE>
</HEAD>
<BODY>
<H1><IMG SRC="http://www-bsl.usc.edu:8376/~hbp/groups/cerebellum/pics/sc.gif">D-A Model:  README</H1>
<IMG SRC="http://www-bsl.usc.edu:8376/~hbp/groups/cerebellum/pics/USCBar_thick.gif">
<A HREF="http://www-bsl.usc.edu:8376/~hbp/groups/cerebellum/nsl/instr/saccade.txt"><LI>Main Menu. </A>
<BR>
<PRE>
nsl
This document explains how to run the saccade model that is reported
in the paper by Dominey and Arbib "A Cortico-Subcortical Model for Generation
of Spatially Accurate Sequential Saccades"

Input files that provide the correct visual and electrical stimulation
for the various saccade tasks.

To explore the model, start openwindows by typing "openwin"
then open a command-tool and type 

nsl
load set_up_testing

This will give you a windows showing the parietal cortex quasi-visual cells -
PPqv (which provide all visual input to the rest of cortex); the QVMASK,
which implements shifting;  Horizontal and vertical eye position; LLBNs - 
the long lead burst neurons of the brainstem.

Now, you can load any of the input files described below, and run.

In between runs, clear the data structures with the command
	load clear2

To clear the values of the electrical stimulation after a colliding
or compensatory saccade type
	load clear_stim


To get a figure that shows single unit activity corresponding to the
given task, we have provided window definition files for the specific tasks.

		More Specifics on Running the Model
--------------------------------------------------------------------

- Always
- 1st/ cd NSL2
- 2nd/ openwin

- I. run the model as it is

a.  with a specific window file (listed below)
- 3rd/ nsl
nsl> load initialize
nsl> load "window file" (some are listed below)
nsl> load "input file"
nsl> run 
 

b.  with a standard set of windows that will be good for all the tasks
nsl> load set_up_testing
nsl> load "input file"
nsl> run 

- II. you want to change some parameters
   In a text editor
- edit "set_parms2.nsl" to change the parameters as you want them
- save

nsl> load set_parms2
nsl> load clear2
nsl> run

- III. you want to change an equation, but do not need to
	define new parameters


In one editor, edit saccade2.c and make the changes you want

save saccade2.c

exit nsl (if you are in nsl)

recompile the model by typing, in a command window,
	nsl_link saccade2.c lib.c

after it is recompiled, you have a new "nsl" that you can execute
by typing
	nsl

then you get the nsl prompt

nsl>



- IV. you want to add some new parameters
In one editor, edit pfd_params2.h and add "# define new_param 999"

In 2nd editor, edit set_parms2.nsl and add the parameter to 
	the end with a comment

In 3rd editor, edit saccade2.c and 
	a) increase the size of ROW_VEC(P,xxx)
	b) use the new parameter that you defined.  You
		refer to it like this "P.elem(new_param)"

Save all threee

exit nsl (if you are in nsl)

recompile the model by typing, in a command window,
	nsl_link saccade2.c lib.c

after it is recompiled, you have a new "nsl" that you can execute
by typing
	nsl

then you get the nsl prompt

nsl>

___________________________________________________________________
Files:

model:
	saccade2.c  - the model

	lib.c - contains NSLeyemove, NLSshift, NSLwinnertakeall

parameters:

	pfd_params2.h  - defines offsets into P data structure

	set_parms2.nsl	-  loads the data structure with the correct
			    values.  If you want to change a parameter value,
				you must change it in this file, and then

		"load set_parms2"	

		To add a new parameter you must
			1. define it in pfd_params2.h
			2. set the value in set_parms2.nsl
			3. increase the size of the P vector in saccade2.c

window files:


 	DoubleSaccade_cx.nsl - windows for the double saccade single units
	CollidingSaccade_cx.nsl - windows for the colliding saccade single 
								units 
	DynamicRemapping_cx.nsl - the displays of PPqv and QVMASK
	SimpleSaccade_cx.nsl - windows for the simple saccade single units
	CompensatorySaccade_cx.nsl - windows for the compens. sacc. single 
								units
	MemorySaccadeWin.nsl - windows for mem. sac. single units

input files:	

	DoubleL_cx.nsl - the input data for a double saccade with the first 
		target 20 deg left and second target is 40 deg up

    	Simple.nsl - the input data for a simple saccade with target 
		20 deg up and 20 deg right ---this is the one that to use
		in the simulation because of the behaviour of the PPqv---

	Collision4020_cx.nsl - the input data for a colliding saccade with the
		visual target 40 right, stim 20 up
	
	MemorySaccadeInp.nsl - the input for a mem saccade with the visual 
		target 20 up and 20 right

	DoubleMem_cx.ns - a new experiment that combines shifitng and a
		delay memory of the shifted target

	Compensatory_cx.nsl - a compensatoyr saccade.


utility/tool files:

	clear2.nsl - sets all the values to their "resting" level.  Do this
			before each new trial

	eye_pos_graphs.nsl - horizontal and vertical eye position graphs


Notes on parameters:

1. for the FEF colliding saccade FEFsac_k1 should be set to 4.8 in 
	set_parms2.nsl to simulate the stimulation (see set_parms2.nsl)

2.  for SC collision SC_k3 7.

3.  for memory saccades, set QVMASK_k1 0 (disables intrinsic memory in PPqv)
			fef_mem_k2 1

4.  the colliding saccades are sensitive to ALL parameter changes - after
	changes, be sure to verify that these collisions still work.




-----


some additional notes are in the file SimulationLog
19X19 conversion
saccade3.c, lib3.c, newsimple.nsl,
load clear3 before doing anything.

set data_value M2
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 .5 .5 .5 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 .5 .5 .5 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 .5 .5 .5 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1



August 11, 1992 - Huntington's disease experiments

1) increased distractability:
in saccade with overlap (ContinuousStimulus in Lasker's terms), we see 30%
chance of going to distractor
	a) CORTICAL - fixation related cells in FEF not working
	b) SNR/CD - tonic inhibition of SC reduced

2) increased latency;


Nov 9, 1992:  Reproduction of Dassonville et al Visual Neuroscience paper on
damped position signal.

Note;  some of the standard parameter files for the saccade model may have been 
changed for the HD experiments. In the future we should try to avoid that.
a) looks like qv 'memory' fxn killed - try params from /usr/dominey/saccade
inserm# mv set_parms2.nsl HD_parms.nsl
inserm# cp ../../set_parms2.nsl set_parms2.nsl


DoubleL_cx.nsl - correct
double_late.nsl 230-245- just before saccade

double_late2.nsl - 280-295 still before saccade, less error
double_late3.nsl - 290-305


dass1.nsl 200-215
problem:  the time constant for the damped signal is .006, too short.  When I
increase it...  No - wrong strategy.  

1. RTNCHANGE itself should have a time 
constant itself. so, change to pfd_parms2, set_parms2 etc.

2.  the wta used in llbn should be a center of mass calculator

ok - using damped signal, need to tune
M3 as subtraction of SC_Delay, because the shift into the center doesnt work.
fix it.  The damped signal looks good!

Fig 2 repro with DoubleL_cx, dass4, dass6, dass11

Jan 15, 1992 in LA;

Now we address the final point, the supeficial sc collision:
1.  first try a family of collisions for fef and deep sc (dominey/*.snap)
Collision4020_cx.nsl
set stim_t0 0.135
set stim_t1 0.175 

Collision4020_cx1.nsl
set stim_t0 0.145
set stim_t1 0.185 

Collision4020_cx2.nsl
set stim_t0 0.155
set stim_t1 0.195 

Collision4020_cx3.nsl
set stim_t0 0.175
set stim_t1 0.205 

Collision4020_cx4.nsl
set stim_t0 0.195
set stim_t1 0.225 

Determoined that we were not using the damped position signal for the shift.
Now, when using it,if it is too slow, the shift doesn't occur fast enough, and
the activity in llbmn builds up for the unshifted target, causing an uncorrected saccade there!!!
A hack fix is to delay the second target a bit;
DoubleL_cx
set stim_t0 0.12
set stim_t1 0.17
set stim_t0 .19 //0.09// 0.06
set stim_t1 .205 //0.10//0.09
dass1
set stim_t0 .200 //0.09// 0.06
set stim_t1 .215 //0.10//0.09
solves that problem, but we still have a shift
1 before move, small overshoot
2 same
3 same
4  these are 15ms
5 15ms , late, accurate eff and shift delay correct
6 less accurate, over
7 
8 movement conmpleted, but unexpected result
9 movement completed, undershoot
10 mc, ok
11 pure visual second saccade, accurate

may want to check retina and transmissionm delay

30ms from retina to fef .006
40ms	.008

increasing distance of first saccade to get longer shift period.
dass12.nsl, 2nd tgt at 310
saccade begins arounnd 270


A-30 degrees right, B-20 right, 20 up
250, 260 at saccade, overshifted llbm weird
270 - just at saccade, overshifted

290 - tgt appears during saccade, and hits retina at 10, 20, then
gets shfited too far by delay signal, same for 280


dassr310.nsl 310-325 - target appears just at end of saccade, thus in correct retinal location for final movement. But the shift continues after the movement, thus shifts the target and the saccade errors with and overshoot. same for 320
340 tgt arrives after shift and is accurate
system problem - after the fist saccade, the sc gets immediately activated by the second target...  this triggers the brainstem, and the residual llbn activity produces another sacade - before we qvoided this by not having the two targets in the same hemifield - a bit cheating...

qv - relation between two scaliing factors


dassrb210.nsl 30right,d 20 up - fine  (very early normal)

250 efferent delay and shift delay matched

270 target comes late, and part of shift is missed (early undershoot)

280 retina is moved when tqrget appears, but accurate

290 -like 280, but the final shift is too far, but the model error ends up producing the correct saccade to hor zero!!

295 - overshift due to residual shift, with error (later overshoot)

300 end of saccade when seen, but no residual shift

Bugs:

1.  trigger is activated as described above, this limits or repertoir of double combinations to being in different hemifields

2.  shifter often produces multiple final sites of activity - need some kind of center of mass function, rather than winner take all

3. calibration of large saccades does not seem correct, so for in these cases of correct double with h0, we get overshoot error

Questions:

set data_value qvmask2
-0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 
-0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 
-0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 
-0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 
-0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 
-0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 
-0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 
-0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 
-0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2   0    0    0  -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 
-0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2   0    0    0  -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 
-0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2   0    0    0  -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 
-0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 
-0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 
-0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 
-0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 
-0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 
-0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 
-0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 
-0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 -0.2 

