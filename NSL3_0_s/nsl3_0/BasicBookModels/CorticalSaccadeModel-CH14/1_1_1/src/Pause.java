/* This file is generated by  NSL3.0 preprocessor*/

/* SCCS  %W% --- %G% -- %U% */
/*Pause
* pause -  module
* @see  Pause.nslm
* @version 98/6/18
* @author Dominey and Alexander
*/
 import nslj.src.system.*; 
 import nslj.src.cmd.*; 
 import nslj.src.lang.*; 
 import nslj.src.math.*; 
 import nslj.src.display.*; 

 public class Pause extends NslModule /*(int stdsz)*/  {

// input ports
public NslDinFloat2 supcol ; /*(stdsz,stdsz)*/  //input
public NslDinFloat2 fefsac ; /*(stdsz,stdsz)*/  //input
public NslDinFloat2 stm ; /*(stdsz,stdsz)*/  //input
public NslDinFloat2 weights ; /*(stdsz,stdsz)*/  //input
public NslDinFloat2 mlbn ; /*(stdsz,stdsz)*/  //input
public NslDinFloat0 ebn ; /*()*/  //input

// output ports
public NslDoutFloat0 pause ; /* ()*/ // output
// vars
private NslFloat0 pausePot ; /* ()*/	
  // pausePot cells are inhibited by Trig and are reactivated when RI = DELTA
private NslFloat2 arrTrig ; /* (stdsz,stdsz)*/	
private NslFloat0 dataTrig ; /* ()*/
private NslFloat0 dataTrigN ; /* ()*/
private NslFloat0 dataIdelta ; /* ()*/	
private NslFloat0 datadelta ; /*()*/
private NslFloat2 arrdelta ; /* (stdsz,stdsz)*/
private NslFloat2 arrMask ; /*(stdsz,stdsz)*/


// parameters 
private NslFloat0 	alldirectionpause_k1 ; /*()*/
private NslFloat0 	arrTrig_tm ; /*()*/
private NslFloat0 	arrTrig_k1 ; /*()*/
private NslFloat0 	pausePot_tm ; /*()*/
private NslFloat0 	pausePot_k1 ; /*()*/
private NslFloat0 	dataTrigN_k1 ; /*()*/
private NslFloat0 	dataTrigN_k2 ; /*()*/
private NslFloat0 	dataRTrigN_k3 ; /*()*/
private NslFloat0 	arrMask_k1 ; /*()*/
private NslFloat0 	arrMask_k2 ; /*()*/
private NslFloat0 	arrMask_k3 ; /*()*/
private NslFloat0 	dataIdelta_k1 ; /*()*/
private NslFloat0 	datadelta_k1 ; /*()*/
private NslFloat0 	datadelta_k2 ; /*()*/
private NslFloat0 	datadelta_k3 ; /*()*/
private NslFloat0 	pause_k1 ; /*()*/
private NslFloat0 	pause_k2 ; /*()*/
private NslFloat0 	pause_k3 ; /*()*/

// resettable integrators that are compared with DELTA
private NslFloat0 resetInteg ; /* ()*/  
private NslFloat0 resetIntegPot ; /* ()*/
// parameters 
private NslFloat0 	resetIntegPot_k1 ; /*()*/
private NslFloat0 	resetInteg_k1 ; /*()*/
private NslFloat0 	resetInteg_k2 ; /*()*/
private NslFloat0 	resetInteg_k3 ; /*()*/
private  float maxdelta;

public  void initModule() {	
}

public  void initRun() {
	resetInteg.set(0);

	 pause.set(0);
       pausePot.set(0);
       arrTrig.set(0);
       dataTrig.set(0);
       dataTrigN.set(0);
       dataIdelta.set(0);
       datadelta.set(0);
       arrdelta.set(0);
       arrMask.set(0);
       maxdelta=0;

	alldirectionpause_k1.set(1.1);
	pausePot_tm.set(0.006);

 	arrTrig_tm.set(0.006);
	arrTrig_k1.set(50);
	// aa: 2.1.7 model had the left pausePot with a k1 of 1 while the rest were 0.1.
	pausePot_k1.set(0.1);
	dataTrigN_k1.set(0);
	dataTrigN_k2.set(0);
	dataRTrigN_k3.set(0);
	arrMask_k1.set(240);
	arrMask_k2.set(0);
	arrMask_k3.set(40);
	dataIdelta_k1.set(3);
	datadelta_k1.set(0);
	datadelta_k2.set(0);
	datadelta_k3.set(0);
	pause_k1.set(8);
	pause_k2.set(300);
	pause_k3.set(0);
	resetIntegPot_k1.set(0.031);
	resetInteg_k1.set(0);
	resetInteg_k2.set(0);
	resetInteg_k3.set(0);


}

public  void simRun() {
	// The trigger cells get input from FEF and supcol.  Once the saccade begins,
	// these cells are inhibited so that residual activity in FEF and supcol won't
	// prevent short saccades from ending
	arrTrig.set(system.nsldiff.eval(arrTrig,arrTrig_tm,
 __nsltmp107=nslj.src.math.NslSub.eval(__nsltmp107,
 __nsltmp105=nslj.src.math.NslAdd.eval(__nsltmp105,
 __nsltmp103=nslj.src.math.NslAdd.eval(__nsltmp103,
 __nsltmp101=nslj.src.math.NslSub.eval(__nsltmp101,0,arrTrig.get()),
 __nsltmp102=nslj.src.math.NslElemMult.eval(__nsltmp102,stm.get(),supcol.get())),
 __nsltmp104=nslj.src.math.NslElemMult.eval(__nsltmp104,stm.get(),fefsac.get())),
 __nsltmp106=nslj.src.math.NslElemMult.eval(__nsltmp106,arrTrig_k1.get(),arrMask.get())))) /* rule 108 */;

	pausePot.set(system.nsldiff.eval(pausePot,pausePot_tm,(
 nslj.src.math.NslAdd.eval(
 nslj.src.math.NslAdd.eval(nslj.src.math.NslSub.eval(0,pausePot),
 nslj.src.math.NslElemMult.eval(pausePot_k1.get(),dataTrigN.get())),datadelta.get()))-(
 nslj.src.math.NslElemMult.eval(alldirectionpause_k1.get(),resetInteg.get())))) /* rule 108 */;

	resetIntegPot.set(
 nslj.src.math.NslSub.eval(
 nslj.src.math.NslAdd.eval(resetInteg.get(),
 nslj.src.math.NslElemMult.eval(resetIntegPot_k1.get(),ebn.get())),pause.get()));
		// this thresholding allows us to manipulate the accuracy
		// of the saccade by specifying how close DELTA and RI
		// must be to terminate the saccade (triger the pausePot cells)


	arrdelta.set(
 __nsltmp108=nslj.src.math.NslElemMult.eval(__nsltmp108,arrMask.get(),weights.get()));  // weights has values that increase
		// as you move to the periphery.  arrMask has a constant
		// value once the inputs are above threshold.  The result
		// is that the spatial FEF and supcol signal gets converted into
		// delatA which is used to produce datadelta which is compared
		// to the resetable integrator to terminate the saccade
//-------------------
	dataTrig.set(NslMaxValue.eval(arrTrig)) /* rule 108 */;
	dataTrigN.set(NslRamp.eval(dataTrig,dataTrigN_k1,dataTrigN_k2,dataRTrigN_k3)) /* rule 108 */;
		// this thresholding allows us to manipulate the accuracy
		// of the saccade by specifying how close DELTA and RI
		// must be to terminate the saccade (triger the pausePot cells)
	resetInteg.set(NslRamp.eval(resetIntegPot,resetInteg_k1,resetInteg_k2,resetInteg_k3)) /* rule 108 */;

	arrMask.set(NslStep.eval(mlbn,arrMask_k1,arrMask_k2,arrMask_k3)) /* rule 108 */;
		// fires at a fixed rate when llbns above threshold.
		// used to get the Delta

	maxdelta=NslMaxValue.eval(arrdelta)/* rule 102*/;
	dataIdelta.set((maxdelta)-(
 nslj.src.math.NslElemMult.eval(dataIdelta_k1.get(),pause.get())));
	datadelta.set(NslRamp.eval(dataIdelta,datadelta_k1,datadelta_k2,datadelta_k3)) /* rule 108 */;
	pause.set(NslStep.eval(pausePot,pause_k1,pause_k2,pause_k3)) /* rule 108 */;

	if (system.debug>=9) {
		System.out.println("debug: Pause: dataTrigN");
		System.out.println(dataTrigN);
		System.out.println("debug: Pause: pause");
		System.out.println(pause);
	}
}
	/* nslInitTempModule inserted by NPP */
public void nslInitTempModule() {
	/* Instantiation statements generated by NslPreProcessor */
	/* temporary variables */
	__nsltmp101 = new float[1][1];
	__nsltmp102 = new float[1][1];
	__nsltmp103 = new float[1][1];
	__nsltmp104 = new float[1][1];
	__nsltmp105 = new float[1][1];
	__nsltmp106 = new float[1][1];
	__nsltmp107 = new float[1][1];
	__nsltmp108 = new float[1][1];
	/* end of automatic instantiation statements */
	/* Intialisation statements generated by NslPreProcessor */
	/* temporary variables */
	/* end of automatic intialisation statements */
}

	/* nslInitTempRun inserted by NPP */
public void nslInitTempRun() {
	/* Intialisation statements generated by NslPreProcessor */
	/* temporary variables */
	for (int i = 0; i < __nsltmp101.length; i++) {
		for (int j = 0; j < __nsltmp101[0].length; j++) {
			__nsltmp101[i][j] = 0;
		}
	}
	for (int i = 0; i < __nsltmp102.length; i++) {
		for (int j = 0; j < __nsltmp102[0].length; j++) {
			__nsltmp102[i][j] = 0;
		}
	}
	for (int i = 0; i < __nsltmp103.length; i++) {
		for (int j = 0; j < __nsltmp103[0].length; j++) {
			__nsltmp103[i][j] = 0;
		}
	}
	for (int i = 0; i < __nsltmp104.length; i++) {
		for (int j = 0; j < __nsltmp104[0].length; j++) {
			__nsltmp104[i][j] = 0;
		}
	}
	for (int i = 0; i < __nsltmp105.length; i++) {
		for (int j = 0; j < __nsltmp105[0].length; j++) {
			__nsltmp105[i][j] = 0;
		}
	}
	for (int i = 0; i < __nsltmp106.length; i++) {
		for (int j = 0; j < __nsltmp106[0].length; j++) {
			__nsltmp106[i][j] = 0;
		}
	}
	for (int i = 0; i < __nsltmp107.length; i++) {
		for (int j = 0; j < __nsltmp107[0].length; j++) {
			__nsltmp107[i][j] = 0;
		}
	}
	for (int i = 0; i < __nsltmp108.length; i++) {
		for (int j = 0; j < __nsltmp108[0].length; j++) {
			__nsltmp108[i][j] = 0;
		}
	}
	/* end of automatic intialisation statements */
}

	/* nslInitTempTrain inserted by NPP */
public void nslInitTempTrain() {
	/* Initialisation statements generated by NslPreProcessor */
	/* temporary variables */
	/* end of automatic intialisation statements */
}

	/* Declaration statements generated by NslPreProcessor */
	/* makeinst() declared variables */
	/* temporary variables */
	private  float[][] __nsltmp101;
	private  float[][] __nsltmp102;
	private  float[][] __nsltmp103;
	private  float[][] __nsltmp104;
	private  float[][] __nsltmp105;
	private  float[][] __nsltmp106;
	private  float[][] __nsltmp107;
	private  float[][] __nsltmp108;
	/* constructor and related methods */
	/* nsl declarations */
	int stdsz;

	 /*GENERIC CONSTRUCTOR:   */
	 public Pause(String nslName, NslModule nslParent,int stdsz) {
		super(nslName, nslParent);
		this.stdsz = stdsz;
		initSys();
		makeInst(nslName, nslParent,stdsz);
	}
	public void makeInst(String nslName, NslModule nslParent,int stdsz){ 
	 supcol=new NslDinFloat2 ("supcol",this,stdsz,stdsz); //NSLDECLS 
	 fefsac=new NslDinFloat2 ("fefsac",this,stdsz,stdsz); //NSLDECLS 
	 stm=new NslDinFloat2 ("stm",this,stdsz,stdsz); //NSLDECLS 
	 weights=new NslDinFloat2 ("weights",this,stdsz,stdsz); //NSLDECLS 
	 mlbn=new NslDinFloat2 ("mlbn",this,stdsz,stdsz); //NSLDECLS 
	 ebn=new NslDinFloat0 ("ebn",this); //NSLDECLS 
	 pause=new NslDoutFloat0 ("pause",this); //NSLDECLS 
	 pausePot=new NslFloat0 ("pausePot",this); //NSLDECLS 
	 arrTrig=new NslFloat2 ("arrTrig",this,stdsz,stdsz); //NSLDECLS 
	 dataTrig=new NslFloat0 ("dataTrig",this); //NSLDECLS 
	 dataTrigN=new NslFloat0 ("dataTrigN",this); //NSLDECLS 
	 dataIdelta=new NslFloat0 ("dataIdelta",this); //NSLDECLS 
	 datadelta=new NslFloat0 ("datadelta",this); //NSLDECLS 
	 arrdelta=new NslFloat2 ("arrdelta",this,stdsz,stdsz); //NSLDECLS 
	 arrMask=new NslFloat2 ("arrMask",this,stdsz,stdsz); //NSLDECLS 
	 alldirectionpause_k1=new NslFloat0 ("alldirectionpause_k1",this); //NSLDECLS 
	 arrTrig_tm=new NslFloat0 ("arrTrig_tm",this); //NSLDECLS 
	 arrTrig_k1=new NslFloat0 ("arrTrig_k1",this); //NSLDECLS 
	 pausePot_tm=new NslFloat0 ("pausePot_tm",this); //NSLDECLS 
	 pausePot_k1=new NslFloat0 ("pausePot_k1",this); //NSLDECLS 
	 dataTrigN_k1=new NslFloat0 ("dataTrigN_k1",this); //NSLDECLS 
	 dataTrigN_k2=new NslFloat0 ("dataTrigN_k2",this); //NSLDECLS 
	 dataRTrigN_k3=new NslFloat0 ("dataRTrigN_k3",this); //NSLDECLS 
	 arrMask_k1=new NslFloat0 ("arrMask_k1",this); //NSLDECLS 
	 arrMask_k2=new NslFloat0 ("arrMask_k2",this); //NSLDECLS 
	 arrMask_k3=new NslFloat0 ("arrMask_k3",this); //NSLDECLS 
	 dataIdelta_k1=new NslFloat0 ("dataIdelta_k1",this); //NSLDECLS 
	 datadelta_k1=new NslFloat0 ("datadelta_k1",this); //NSLDECLS 
	 datadelta_k2=new NslFloat0 ("datadelta_k2",this); //NSLDECLS 
	 datadelta_k3=new NslFloat0 ("datadelta_k3",this); //NSLDECLS 
	 pause_k1=new NslFloat0 ("pause_k1",this); //NSLDECLS 
	 pause_k2=new NslFloat0 ("pause_k2",this); //NSLDECLS 
	 pause_k3=new NslFloat0 ("pause_k3",this); //NSLDECLS 
	 resetInteg=new NslFloat0 ("resetInteg",this); //NSLDECLS 
	 resetIntegPot=new NslFloat0 ("resetIntegPot",this); //NSLDECLS 
	 resetIntegPot_k1=new NslFloat0 ("resetIntegPot_k1",this); //NSLDECLS 
	 resetInteg_k1=new NslFloat0 ("resetInteg_k1",this); //NSLDECLS 
	 resetInteg_k2=new NslFloat0 ("resetInteg_k2",this); //NSLDECLS 
	 resetInteg_k3=new NslFloat0 ("resetInteg_k3",this); //NSLDECLS 
	}
	/* end of automatic declaration statements */
}
