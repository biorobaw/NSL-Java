/* This file is generated by  NSL3.0 preprocessor*/

/* SCCS @(#)HillclimbCalc.mod	1.1 --- 09/24/99 -- 16:05:43 */
/* Copyright 1999 University of Southern California Brain Lab */
/* Author: Mihai Bota */
/* Coder: Amanda Alexander and Salvador Marmol */
/* email nsl@java.usc.edu */

 import nslj.src.system.*; 
 import nslj.src.cmd.*; 
 import nslj.src.lang.*; 
 import nslj.src.math.*; 
 import nslj.src.display.*; 


 public class HillclimbCalc extends NslModule/*(int weightSize, int areaSize)*/ {

//         int weightSize=4;
//        int areaSize=40;
         int hold_x_y_size=2;

// output ports
public 	NslDoutDouble0 x ; /*()*/
public 	NslDoutDouble0 y ; /*()*/
public 	NslDoutDouble0 distance ; /*()*/
public 	NslDoutDouble2 Weight ; /*(weightSize,weightSize)*/
public 	NslDoutDouble2 areaTrain ; /*(areaSize,areaSize)*/
public 	NslDoutDouble2 areaRun ; /*(areaSize,areaSize)*/

//variables
 	private  double bound;
	private  double smell;
	private  double tree;
	private  int countk;
	private  int countj; 
	private  double nvar; 
	private  double z;
	private  double z1;
	private  double Dtree; 
	private  double Dtree1; 
	private  double dtree_ratio;
	private  double tmp;
	private  double tmp1; 
	private  double idouble;
	private  double jdouble;
	private  int i_index;
	private  int j_index;
	private NslDouble0	rr1 ; /*() */
	private NslDouble0	rr2 ; /*() */
//	private NslDouble0	k() ;
	private NslDouble1      Tree ; /*(hold_x_y_size) */ 
	private NslDouble1      north ; /*(hold_x_y_size)*/
	private NslDouble1 	south ; /*	(hold_x_y_size)*/
	private NslDouble1      west ; /*	(hold_x_y_size)*/
	private NslDouble1	east ; /*	(hold_x_y_size)*/
	private NslDouble2 	weight ; /*(weightSize,weightSize)*/

	private NslDouble2 	weightTrans ; /*(weightSize,weightSize)*/
	private NslDouble2	w ; /*  (weightSize,weightSize)*/
	private NslDouble1	w0 ; /*(weightSize)*/
	private NslDouble0	kx1 ; /*()*/
	private NslDouble0	kx2 ; /*()*/
	private NslDouble1	dist ; /*	(weightSize)*/
	private NslDouble1	X ; /*	(hold_x_y_size)*/
	private NslDouble1	X0 ; /*	(hold_x_y_size)*/
	
	private NslDouble1	Xinit ; /*	(hold_x_y_size)*/
	private NslDouble1	Y ; /*	(weightSize)*/
	private NslDouble1	state ; /*   (weightSize)*/
	private NslDouble2	stateTemp ; /*   (weightSize,1)*/
	private NslDouble1	stateTemp2 ; /*   (weightSize)*/
	private NslDouble1	XX ; /*	(weightSize)*/
	private NslDouble2	XXTrans ; /*	(weightSize,1)*/

	private NslDouble1	randomVector ; /*(weightSize)*/
	private NslDouble1	diffT ; /*	(hold_x_y_size)*/
	private NslDouble1	diffT1 ; /*	(hold_x_y_size)*/
	private NslDouble1	diff0 ; /*	(hold_x_y_size)*/
	private NslDouble1	diff1 ; /*	(hold_x_y_size)*/
	private NslDouble1	diff2 ; /*	(hold_x_y_size)*/
	private NslDouble1	diff3 ; /*	(hold_x_y_size)*/

	private  int halfAreaSize;
	private  int areaSizeMinus1;
	private  int oneEigthAreaSize;
	
// initialize all needed parameters
public  void initTrain() { 
	halfAreaSize=(int)areaSize/2;
	oneEigthAreaSize=(int)areaSize/8;
	areaSizeMinus1=areaSize-1;
	(X).set(0,3);
	(X).set(1,3);
	x.set(0);
	y.set(0);
	(X0).set(0,3);
	(X0).set(1,3);
	(Xinit).set(0,-(3));
        (Xinit).set(1,-(3));
	smell=7;
	tree=10;
	bound=0.005;
	(Tree).set(0,0);
	(Tree).set(1,0);
	(north).set(0,0);
	(north).set(1,oneEigthAreaSize);
	(south).set(0,0);
	(south).set(1,-(oneEigthAreaSize));
	(west).set(0,-(oneEigthAreaSize));
	(west).set(1,0);
	(east).set(0,oneEigthAreaSize);
	(east).set(1,0);
	nvar=0.01;
        areaTrain.set(0);
	(areaTrain).set(19,0,1);
	(areaTrain).set(halfAreaSize,0,1);
	(areaTrain).set(21,0,1);
	(areaTrain).set(0,19,1);
	(areaTrain).set(0,halfAreaSize,1);
	(areaTrain).set(0,21,1);
	(areaTrain).set(39,19,1);
	(areaTrain).set(39,21,1);
	(areaTrain).set(39,halfAreaSize,1);
	(areaTrain).set(19,39,1);
	(areaTrain).set(halfAreaSize,39,1);
	(areaTrain).set(21,39,1);
	(areaTrain).set(halfAreaSize,halfAreaSize,1);
	areaRun.set(areaTrain);
	weight.set(NslRandom.eval(weight)) /* rule 108 */;
	weight.set(
 __nsltmp102=nslj.src.math.NslSub.eval(__nsltmp102,
 __nsltmp101=nslj.src.math.NslElemMult.eval(__nsltmp101,weight.get(),0.1),0.05));	
	w0.set(0);
	state.set(w0);
} //end initTrain

public  void simTrain() {
	makeCalculations(X,areaTrain);
} //end simTrain

public  void simRun() {
	makeCalculations(Xinit,areaRun);
} //end simRun

public  void makeCalculations(NslDouble1 X, NslDouble2 area) {
	diffT.set(
 __nsltmp103=nslj.src.math.NslSub.eval(__nsltmp103,Tree.get(),X.get()));
	Dtree=NslOperator.distance.eval(diffT.get(0),diffT.get(1))/* rule 102*/;

	diff0.set(
 __nsltmp104=nslj.src.math.NslSub.eval(__nsltmp104,north.get(),X.get()));
	(dist).set(0,NslOperator.distance.eval(diff0.get(0),diff0.get(1)))/* rule 100 */;

	diff1.set(
 __nsltmp105=nslj.src.math.NslSub.eval(__nsltmp105,south.get(),X.get()));
	(dist).set(1,NslOperator.distance.eval(diff1.get(0),diff1.get(1)))/* rule 100 */;

	diff2.set(
 __nsltmp106=nslj.src.math.NslSub.eval(__nsltmp106,east.get(),X.get()));
	(dist).set(2,NslOperator.distance.eval(diff2.get(0),diff2.get(1)))/* rule 100 */;

	diff3.set(
 __nsltmp107=nslj.src.math.NslSub.eval(__nsltmp107,west.get(),X.get()));
	(dist).set(3,NslOperator.distance.eval(diff3.get(0),diff3.get(1)))/* rule 100 */;

	state.set(w0);

	XX.set(
 __nsltmp109=nslj.src.math.NslSub.eval(__nsltmp109,1,
 __nsltmp108=nslj.src.math.NslElemDiv.eval(__nsltmp108,dist.get(),smell)));
	XX.set(
 __nsltmp110=nslj.src.math.NslElemMult.eval(__nsltmp110,0.5,NslRamp.eval(XX)));

	dtree_ratio=(1-Dtree/tree);
	z=(0.5)*(NslRamp.eval(dtree_ratio));

        weightTrans.set(NslTrans.eval(weight)) /* rule 108 */;
        XXTrans.set(NslTrans.eval(XX)) /* rule 108 */;
//	state=state+nslGetColumn((weightTrans*XXTrans),0);
	//99/9/4 aa: change in future
	stateTemp.set(NslProd.eval(weightTrans,XXTrans)) /* rule 108 */;  //The * calculates product with matrix and vector.
 	stateTemp2.set(NslGetColumn.eval(stateTemp,0)) /* rule 108 */;  // but product leaves you with a matrix n by 1.
	state.set(
 __nsltmp111=nslj.src.math.NslAdd.eval(__nsltmp111,state.get(),stateTemp2.get()));  //vector plus vector

	randomVector.set(
 __nsltmp114=nslj.src.math.NslAdd.eval(__nsltmp114,state.get(),
 __nsltmp113=nslj.src.math.NslSub.eval(__nsltmp113,
 __nsltmp112=nslj.src.math.NslElemMult.eval(__nsltmp112,NslRandom.eval(randomVector),0.1),0.05)));	

	// Y is a random one dimensional array of 1's and 0's
	Y.set(NslStep.eval(randomVector,0,0,1)) /* rule 108 */; 

	if (((Y).get(0))==(1))
		(X).set(1,((X).get(1))+(0.25));
	if (((Y).get(1))==(1))
		(X).set(1,((X).get(1))-(0.25));
	if (((Y).get(2))==(1))
		(X).set(0,((X).get(0))+(0.25));
	if (((Y).get(3))==(1))
		(X).set(0,((X).get(0))-(0.25));

	// aa:changed orig since x maps to j, and y maps to i
	y.set(-((X).get(0)));  //X[0]=delta_i
	x.set((X).get(1));  //X[1]=delta_j
	if (((X).get(0))>(oneEigthAreaSize)) {
	  System.out.println(("HillclimbCalc: Error: X[0] index out of range :")+(X.get(0)));
	  (X).set(0,oneEigthAreaSize);
	}
	if (((X).get(0))<(-(oneEigthAreaSize))) {
	  System.out.println(("HillclimbCalc: Error: X[0] index out of range :")+(X.get(0)));
	  (X).set(0,-(oneEigthAreaSize));
	}
	if (((X).get(1))>(oneEigthAreaSize)) {
	  System.out.println(("HillclimbCalc: Error: X[1] index out of range :")+(X.get(1)));
	  (X).set(1,oneEigthAreaSize);
	}
	if (((X).get(1))<(-(oneEigthAreaSize))) {
	  System.out.println(("HillclimbCalc: Error: X[1] index out of range :")+(X.get(1)));
	  (X).set(1,-(oneEigthAreaSize));
	}
	if (((X).get(0))<=(0)) {
	  idouble=(halfAreaSize)+((weightSize)*((X).get(0)));//i must be between 0 and 39
	} else {
	  idouble=((halfAreaSize)+((weightSize)*((X).get(0))))-(1);//i must be between 0 and 39
	}
	if (((X).get(1))<=(0)) {
	  jdouble=(halfAreaSize)+((weightSize)*((X).get(1)));//j must be between 0 and 39
	} else {
	  jdouble=((halfAreaSize)+((weightSize)*((X).get(1))))-(1);//j must be between 0 and 39
        }

	// use to be just a cast to int
	i_index=(int)NslOperator.rint.eval(idouble)/* rule 112 */;	  
	j_index=(int)NslOperator.rint.eval(jdouble)/* rule 112 */;

	i_index=NslBound.eval(i_index,0,areaSizeMinus1,0,areaSizeMinus1)/* rule 102*/;
	j_index=NslBound.eval(j_index,0,areaSizeMinus1,0,areaSizeMinus1)/* rule 102*/;

	(area).set(i_index,j_index,((area).get(i_index,j_index))+(0.15));

	diffT1.set(
 __nsltmp115=nslj.src.math.NslSub.eval(__nsltmp115,Tree.get(),X.get()));
	Dtree1=NslOperator.distance.eval(diffT1.get(0),diffT1.get(1))/* rule 102*/;

	distance.set(Dtree1);

	dtree_ratio=(1-Dtree1/tree);
	z1=(0.5)*(NslRamp.eval(dtree_ratio));

	tmp=0.25*(z1-z);

	w.set(weight);
	w.set(
 __nsltmp117=nslj.src.math.NslAdd.eval(__nsltmp117,w.get(),
 nslj.src.math.NslProd.eval(
 __nsltmp116=nslj.src.math.NslElemMult.eval(__nsltmp116,tmp,Y.get()),XX.get())));
	kx2.set((10)*(bound));
	kx1.set(nslj.src.math.NslSub.eval(0,kx2));
	w.set(NslBound.eval(w,kx1,kx2,kx1,kx2)) /* rule 108 */;

	weight.set(w);
	Weight.set(
 __nsltmp118=nslj.src.math.NslElemMult.eval(__nsltmp118,10,w.get()));
	tmp1=0.5*(z1-z);

	w0.set(
 __nsltmp120=nslj.src.math.NslAdd.eval(__nsltmp120,w0.get(),
 __nsltmp119=nslj.src.math.NslElemMult.eval(__nsltmp119,tmp1,Y.get())));
	w0.set(NslBound.eval(w0,0,bound,0,bound)) /* rule 108 */;

} //end makeCalculations

	/* nslInitTempModule inserted by NPP */
public void nslInitTempModule() {
	/* Instantiation statements generated by NslPreProcessor */
	/* temporary variables */
	__nsltmp103 = new double[1];
	__nsltmp104 = new double[1];
	__nsltmp105 = new double[1];
	__nsltmp106 = new double[1];
	__nsltmp107 = new double[1];
	__nsltmp108 = new double[1];
	__nsltmp109 = new double[1];
	__nsltmp110 = new double[1];
	__nsltmp111 = new double[1];
	__nsltmp112 = new double[1];
	__nsltmp113 = new double[1];
	__nsltmp114 = new double[1];
	__nsltmp115 = new double[1];
	__nsltmp116 = new double[1];
	__nsltmp117 = new double[1][1];
	__nsltmp118 = new double[1][1];
	__nsltmp119 = new double[1];
	__nsltmp120 = new double[1];
	__nsltmp101 = new double[1][1];
	__nsltmp102 = new double[1][1];
	/* end of automatic instantiation statements */
	/* Intialisation statements generated by NslPreProcessor */
	/* temporary variables */
	for (int i = 0; i < __nsltmp103.length; i++) {
		__nsltmp103[i] = 0;
}
	for (int i = 0; i < __nsltmp104.length; i++) {
		__nsltmp104[i] = 0;
}
	for (int i = 0; i < __nsltmp105.length; i++) {
		__nsltmp105[i] = 0;
}
	for (int i = 0; i < __nsltmp106.length; i++) {
		__nsltmp106[i] = 0;
}
	for (int i = 0; i < __nsltmp107.length; i++) {
		__nsltmp107[i] = 0;
}
	for (int i = 0; i < __nsltmp108.length; i++) {
		__nsltmp108[i] = 0;
}
	for (int i = 0; i < __nsltmp109.length; i++) {
		__nsltmp109[i] = 0;
}
	for (int i = 0; i < __nsltmp110.length; i++) {
		__nsltmp110[i] = 0;
}
	for (int i = 0; i < __nsltmp111.length; i++) {
		__nsltmp111[i] = 0;
}
	for (int i = 0; i < __nsltmp112.length; i++) {
		__nsltmp112[i] = 0;
}
	for (int i = 0; i < __nsltmp113.length; i++) {
		__nsltmp113[i] = 0;
}
	for (int i = 0; i < __nsltmp114.length; i++) {
		__nsltmp114[i] = 0;
}
	for (int i = 0; i < __nsltmp115.length; i++) {
		__nsltmp115[i] = 0;
}
	for (int i = 0; i < __nsltmp116.length; i++) {
		__nsltmp116[i] = 0;
}
	for (int i = 0; i < __nsltmp117.length; i++) {
		for (int j = 0; j < __nsltmp117[0].length; j++) {
			__nsltmp117[i][j] = 0;
		}
	}
	for (int i = 0; i < __nsltmp118.length; i++) {
		for (int j = 0; j < __nsltmp118[0].length; j++) {
			__nsltmp118[i][j] = 0;
		}
	}
	for (int i = 0; i < __nsltmp119.length; i++) {
		__nsltmp119[i] = 0;
}
	for (int i = 0; i < __nsltmp120.length; i++) {
		__nsltmp120[i] = 0;
}
	/* end of automatic intialisation statements */
}

	/* nslInitTempRun inserted by NPP */
public void nslInitTempRun() {
	/* Intialisation statements generated by NslPreProcessor */
	/* temporary variables */
	/* end of automatic intialisation statements */
}

	/* nslInitTempTrain inserted by NPP */
public void nslInitTempTrain() {
	/* Initialisation statements generated by NslPreProcessor */
	/* temporary variables */
	for (int i = 0; i < __nsltmp101.length; i++) {
		for (int j = 0; j < __nsltmp101[0].length; j++) {
			__nsltmp101[i][j] = 0;
		}
	}
	for (int i = 0; i < __nsltmp102.length; i++) {
		for (int j = 0; j < __nsltmp102[0].length; j++) {
			__nsltmp102[i][j] = 0;
		}
	}
	/* end of automatic intialisation statements */
}

	/* Declaration statements generated by NslPreProcessor */
	/* makeinst() declared variables */
	/* temporary variables */
	private  double[] __nsltmp103;
	private  double[] __nsltmp104;
	private  double[] __nsltmp105;
	private  double[] __nsltmp106;
	private  double[] __nsltmp107;
	private  double[] __nsltmp108;
	private  double[] __nsltmp109;
	private  double[] __nsltmp110;
	private  double[] __nsltmp111;
	private  double[] __nsltmp112;
	private  double[] __nsltmp113;
	private  double[] __nsltmp114;
	private  double[] __nsltmp115;
	private  double[] __nsltmp116;
	private  double[][] __nsltmp117;
	private  double[][] __nsltmp118;
	private  double[] __nsltmp119;
	private  double[] __nsltmp120;
	private  double[][] __nsltmp101;
	private  double[][] __nsltmp102;
	/* constructor and related methods */
	/* nsl declarations */
	int weightSize;
	int areaSize;

	 /*GENERIC CONSTRUCTOR:   */
	 public HillclimbCalc(String nslName, NslModule nslParent,int weightSize, int areaSize) {
		super(nslName, nslParent);
		this.weightSize = weightSize;
		this.areaSize = areaSize;
		initSys();
		makeInst(nslName, nslParent,weightSize, areaSize);
	}
	public void makeInst(String nslName, NslModule nslParent,int weightSize,int areaSize){ 
	 x=new NslDoutDouble0 ("x",this); //NSLDECLS 
	 y=new NslDoutDouble0 ("y",this); //NSLDECLS 
	 distance=new NslDoutDouble0 ("distance",this); //NSLDECLS 
	 Weight=new NslDoutDouble2 ("Weight",this,weightSize,weightSize); //NSLDECLS 
	 areaTrain=new NslDoutDouble2 ("areaTrain",this,areaSize,areaSize); //NSLDECLS 
	 areaRun=new NslDoutDouble2 ("areaRun",this,areaSize,areaSize); //NSLDECLS 
	 rr1=new NslDouble0 ("rr1",this); //NSLDECLS 
	 rr2=new NslDouble0 ("rr2",this); //NSLDECLS 
	 Tree=new NslDouble1 ("Tree",this,hold_x_y_size); //NSLDECLS 
	 north=new NslDouble1 ("north",this,hold_x_y_size); //NSLDECLS 
	 south=new NslDouble1 ("south",this,hold_x_y_size); //NSLDECLS 
	 west=new NslDouble1 ("west",this,hold_x_y_size); //NSLDECLS 
	 east=new NslDouble1 ("east",this,hold_x_y_size); //NSLDECLS 
	 weight=new NslDouble2 ("weight",this,weightSize,weightSize); //NSLDECLS 
	 weightTrans=new NslDouble2 ("weightTrans",this,weightSize,weightSize); //NSLDECLS 
	 w=new NslDouble2 ("w",this,weightSize,weightSize); //NSLDECLS 
	 w0=new NslDouble1 ("w0",this,weightSize); //NSLDECLS 
	 kx1=new NslDouble0 ("kx1",this); //NSLDECLS 
	 kx2=new NslDouble0 ("kx2",this); //NSLDECLS 
	 dist=new NslDouble1 ("dist",this,weightSize); //NSLDECLS 
	 X=new NslDouble1 ("X",this,hold_x_y_size); //NSLDECLS 
	 X0=new NslDouble1 ("X0",this,hold_x_y_size); //NSLDECLS 
	 Xinit=new NslDouble1 ("Xinit",this,hold_x_y_size); //NSLDECLS 
	 Y=new NslDouble1 ("Y",this,weightSize); //NSLDECLS 
	 state=new NslDouble1 ("state",this,weightSize); //NSLDECLS 
	 stateTemp=new NslDouble2 ("stateTemp",this,weightSize,1); //NSLDECLS 
	 stateTemp2=new NslDouble1 ("stateTemp2",this,weightSize); //NSLDECLS 
	 XX=new NslDouble1 ("XX",this,weightSize); //NSLDECLS 
	 XXTrans=new NslDouble2 ("XXTrans",this,weightSize,1); //NSLDECLS 
	 randomVector=new NslDouble1 ("randomVector",this,weightSize); //NSLDECLS 
	 diffT=new NslDouble1 ("diffT",this,hold_x_y_size); //NSLDECLS 
	 diffT1=new NslDouble1 ("diffT1",this,hold_x_y_size); //NSLDECLS 
	 diff0=new NslDouble1 ("diff0",this,hold_x_y_size); //NSLDECLS 
	 diff1=new NslDouble1 ("diff1",this,hold_x_y_size); //NSLDECLS 
	 diff2=new NslDouble1 ("diff2",this,hold_x_y_size); //NSLDECLS 
	 diff3=new NslDouble1 ("diff3",this,hold_x_y_size); //NSLDECLS 
	}
	/* end of automatic declaration statements */
} //end class
